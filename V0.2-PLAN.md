# domain-model v0.2 Implementation Plan

**Status:** Planning (Revised)  
**Theme:** "Ergonomics without magic"  
**Target:** 3-4 weeks after v0.1 feedback  
**Focus:** Derive macro + collection validation + better diagnostics

**Revision Notes:** Updated based on feedback to avoid macro complexity creep, improve path handling, and tighten the contract.

---

## Key Revisions from Original Plan

### 1. Workspace Dependencies
**Change:** Don't use `[workspace.dependencies]` for inter-crate deps.  
**Reason:** Avoids confusing resolution when publishing. Examples/tests use path deps directly; published crates use normal semver.

### 2. Rule References in Generated Code
**Change:** Pass `&rule` instead of moving rules.  
**Reason:** Cleaner error spans, avoids unnecessary moves.

**Generated code:**
```rust
let rule = rules::min_len(3).and(rules::max_len(50));
if let Err(e) = validate("name", self.name.as_str(), &rule) {
    err.extend(e);
}
```

### 3. Attribute Combination Matrix - Relaxed
**Change:** Allow `custom` to combine with other attributes as escape hatch.  
**Reason:** Users will need this flexibility; strict prohibition is unnecessarily limiting.

**Updated matrix:** `custom` can combine with `length`, `range`, and `nested` (as post-validate hook).

### 4. Custom Validation Path Handling
**Change:** Add `ValidationError::prefixed()` method instead of mutating violations in-place.  
**Reason:** Cleaner, fewer bugs, easier to reason about.

**Generated code:**
```rust
if let Err(e) = validate_dates(&self.date_range) {
    err.extend(e.prefixed("date_range"));
}
```

### 5. Type Checking Limits
**Change:** Only structural checks in macro, let rustc handle trait bounds.  
**Reason:** Attempting to "prove numeric" is fragile and error-prone.

**What we check:**
- ✅ `Vec<T>` vs non-Vec
- ✅ `String`/`&str`/`Cow<str>`
- ✅ `Option<T>`, `Box<T>` wrappers

**What rustc checks:**
- Trait bounds (`PartialOrd + Copy + Display`)
- Generic constraints

### 6. Generics Strategy
**Change:** Copy generics where-clause verbatim, add only required `T: Validate` bounds.  
**Reason:** Keeps surprises low, avoids complex bound inference.

### 7. Path Construction
**Change:** Use structured `Path` values, not `format!()` strings.  
**Reason:** Avoids allocation, more correct, handles edge cases better.

**Generated code:**
```rust
// Old (wrong):
err.merge_prefixed(format!("rooms[{}]", i), e);

// New (correct):
err.merge_prefixed(Path::root().field("rooms").index(i), e);
```

### 8. Success Criteria
**Change:** Focus on behavior coverage, not meaningless % metrics.  
**Reason:** Trybuild + integration tests are the real quality bar.

**New criteria:**
- All supported attributes covered by pass + fail tests
- All diagnostics have golden `.stderr` files
- All examples compile and run correctly

---

## Overview

v0.2 adds `#[derive(Validate)]` to eliminate boilerplate while maintaining the explicit, composable design from v0.1. The goal is to make users say: "This is nicer than hand-writing Validate impls."

### What Changes

**Before (v0.1):**
```rust
impl Validate for BookingRequest {
    fn validate(&self) -> Result<(), ValidationError> {
        let mut err = ValidationError::default();
        
        if let Err(e) = validate("name", self.name.as_str(), rules::min_len(1)) {
            err.extend(e);
        }
        
        if let Err(e) = self.guest.validate() {
            err.merge_prefixed("guest", e);
        }
        
        if err.is_empty() { Ok(()) } else { Err(err) }
    }
}
```

**After (v0.2):**
```rust
#[derive(Validate)]
struct BookingRequest {
    #[validate(length(min = 1))]
    name: String,
    
    #[validate(nested)]
    guest: Guest,
    
    #[validate(range(min = 1, max = 10))]
    guests: u8,
}
```

---

## Crate Structure

```text
domain-model/
├── domain-model/              # Core validation (v0.1 code + helpers)
├── domain-model-derive/       # Proc macro crate
└── examples/
    ├── v1_manual.rs          # Show v0.1 manual impl
    ├── v2_derived.rs         # Show v0.2 derive
    └── v2_collections.rs     # Vec/collection validation
```

### Workspace Cargo.toml

```toml
[workspace]
members = ["domain-model", "domain-model-derive"]
resolver = "2"

[workspace.dependencies]
domain-model = { version = "0.2", path = "domain-model" }
```

### domain-model-derive/Cargo.toml

```toml
[package]
name = "domain-model-derive"
version = "0.2.0"
edition = "2021"
rust-version = "1.65"

[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0", features = ["full", "extra-traits"] }
quote = "1.0"
proc-macro2 = "1.0"

[dev-dependencies]
trybuild = "1.0"
```

---

## Supported Attributes (v0.2)

### 1. String Length Validation

```rust
#[validate(length(min = 3, max = 50))]
name: String

#[validate(length(min = 3, max = 50, code = "invalid_name", message = "Name must be 3-50 chars"))]
name: String
```

**Allowed on:** `String`, `&str`, `Cow<'_, str>`

**Defaults:**
- `code`: `"invalid_length"`
- `message`: Auto-generated from min/max

**Generated code:**
```rust
if let Err(e) = validate("name", self.name.as_str(), 
    rules::min_len(3).and(rules::max_len(50))) {
    err.extend(e);
}
```

### 2. Numeric Range Validation

```rust
#[validate(range(min = 1, max = 10))]
guests: u8

#[validate(range(min = 18, max = 120, code = "invalid_age"))]
age: u8
```

**Allowed on:** Types implementing `PartialOrd + Copy + Display`

**Defaults:**
- `code`: `"out_of_range"`
- `message`: Auto-generated

**Generated code:**
```rust
if let Err(e) = validate("guests", &self.guests, rules::range(1, 10)) {
    err.extend(e);
}
```

### 3. Nested Validation

```rust
#[validate(nested)]
guest: Guest

#[validate(nested)]
guest: Option<Guest>

#[validate(nested)]
guest: Box<Guest>
```

**Allowed on:** `T: Validate`, `Option<T>`, `Box<T>`

**Generated code:**
```rust
// T: Validate
if let Err(e) = self.guest.validate() {
    err.merge_prefixed("guest", e);
}

// Option<T>
if let Some(ref guest) = self.guest {
    if let Err(e) = guest.validate() {
        err.merge_prefixed("guest", e);
    }
}

// Box<T>
if let Err(e) = self.guest.validate() {
    err.merge_prefixed("guest", e);
}
```

### 4. Collection (Each) Validation

```rust
#[validate(each(nested))]
rooms: Vec<Room>

#[validate(each(range(min = 1, max = 4)))]
guest_counts: Vec<u8>

#[validate(each(length(min = 1, max = 50)))]
names: Vec<String>
```

**Allowed on:** `Vec<T>` (v0.2 only; slices/HashSet in v0.3)

**Generated code:**
```rust
// each(nested)
for (i, room) in self.rooms.iter().enumerate() {
    if let Err(e) = room.validate() {
        err.merge_prefixed(format!("rooms[{}]", i), e);
    }
}

// each(range)
for (i, count) in self.guest_counts.iter().enumerate() {
    if let Err(e) = validate(
        format!("guest_counts[{}]", i),
        count,
        rules::range(1, 4)
    ) {
        err.extend(e);
    }
}
```

### 5. Custom Validation

```rust
#[validate(custom = "validate_dates")]
date_range: DateRange

#[validate(custom = "my_module::check_email")]
email: String
```

**Function signature (enforced):**
```rust
fn validate_dates(value: &DateRange) -> Result<(), ValidationError>
```

**Generated code (using prefixed helper):**
```rust
if let Err(e) = validate_dates(&self.date_range) {
    err.extend(e.prefixed("date_range"));
}
```

**How prefixed() works:**
- Takes each violation in the error
- Prepends the given path segment to existing paths
- Returns new ValidationError with updated paths
- Works correctly whether custom fn returns root-level or nested paths

---

## Attribute Composition Rules

### Allowed Combinations

```rust
// Multiple constraints on one field (custom as escape hatch)
#[validate(length(min = 1, max = 50))]
#[validate(custom = "check_profanity")]
name: String

// Nested + custom (custom as post-validate hook)
#[validate(nested)]
#[validate(custom = "check_email_domain")]
email: Email  // OK: custom runs after nested validation

// Each cannot combine (collection-level only)
#[validate(each(nested))]
rooms: Vec<Room>  // OK

#[validate(each(nested))]
#[validate(custom = "foo")]  // ERROR: each is exclusive
rooms: Vec<Room>
```

### Combination Matrix (Revised)

| Attribute | length | range | nested | each | custom |
|-----------|--------|-------|--------|------|--------|
| length    | ❌     | ❌    | ❌     | ❌   | ✅     |
| range     | ❌     | ❌    | ❌     | ❌   | ✅     |
| nested    | ❌     | ❌    | ❌     | ❌   | ✅     |
| each      | ❌     | ❌    | ❌     | ❌   | ❌     |
| custom    | ✅     | ✅    | ✅     | ❌   | ✅     |

**Rationale:** `custom` serves as the escape hatch. Users can combine it with basic rules for post-processing or additional checks. `each` is collection-level and exclusive (apply rules to each item OR use custom for the whole collection).

---

## Diagnostics (Compile Errors)

v0.2 must provide clear, actionable compile errors for common mistakes.

### Type Mismatches (Structural Checks Only)

The macro performs **structural checks** (what we can reliably detect) and lets rustc handle trait bound errors.

#### String on Range

```rust
#[derive(Validate)]
struct Bad {
    #[validate(range(min = 1, max = 10))]
    name: String,  // ERROR: structural mismatch
}
```

**Macro error (we detect this):**
```text
error: #[validate(range)] requires a type that implements PartialOrd + Copy + Display
  --> src/main.rs:4:5
   |
4  |     #[validate(range(min = 1, max = 10))]
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: found type: String
   = help: use #[validate(length(...))] for string types
```

#### Non-numeric Type on Range (Let Rustc Handle)

```rust
#[derive(Validate)]
struct Bad {
    #[validate(range(min = 1, max = 10))]
    custom_type: MyType,  // We don't detect this - rustc will
}
```

**Rustc error (trait bound failure):**
```text
error[E0277]: the trait bound `MyType: PartialOrd` is not satisfied
  --> src/generated.rs:XX:YY
   |
   | rules::range(1, 10)
   |        ^^^^^ the trait `PartialOrd` is not implemented for `MyType`
```

**We don't try to prevent this** - rustc's error is clear enough.

### Collection Type Mismatches

```rust
#[derive(Validate)]
struct Bad {
    #[validate(each(nested))]
    guest: Guest,  // ERROR: not a collection
}
```

**Error message:**
```text
error: #[validate(each(...))] requires a collection type (Vec<T>)
  --> src/main.rs:4:5
   |
4  |     #[validate(each(nested))]
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: found type: Guest
   = help: use #[validate(nested)] for non-collection types
```

### Missing Trait Bounds

```rust
#[derive(Validate)]
struct Bad {
    #[validate(nested)]
    guest: Guest,  // ERROR: Guest doesn't implement Validate
}
```

**Error message:**
```text
error: #[validate(nested)] requires type to implement Validate trait
  --> src/main.rs:4:5
   |
4  |     #[validate(nested)]
   |     ^^^^^^^^^^^^^^^^^^^^
   |
   = note: type Guest does not implement domain_model::Validate
   = help: add #[derive(Validate)] to Guest or implement Validate manually
```

### Attribute Conflicts

```rust
#[derive(Validate)]
struct Bad {
    #[validate(nested)]
    #[validate(length(min = 1))]
    guest: Guest,  // ERROR: nested cannot combine with other rules
}
```

**Error message:**
```text
error: #[validate(nested)] cannot be combined with other validation attributes
  --> src/main.rs:5:5
   |
5  |     #[validate(length(min = 1))]
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: nested validation validates the entire type, not individual fields
   = help: remove conflicting attributes or use a custom validation function
```

---

## Core Library Enhancements (domain-model)

v0.2 requires these new helpers in the core library to support the derive macro efficiently.

### Critical: Add ValidationError::prefixed()

**This is required for v0.2 custom validation.**

```rust
impl ValidationError {
    /// Create a new error with all paths prefixed
    /// 
    /// This is more efficient and cleaner than mutating violations in-place.
    /// Used by derive macro for custom validation.
    pub fn prefixed(self, prefix: impl Into<Path>) -> Self {
        let prefix = prefix.into();
        let violations = self.violations
            .into_iter()
            .map(|mut v| {
                let mut segments = prefix.0.clone();
                segments.extend(v.path.0);
                v.path = Path(segments);
                v
            })
            .collect();
        
        Self { violations }
    }
}
```

**Why this matters:**
- Avoids in-place mutation of error paths
- Cleaner generated code from macro
- Easier to reason about ownership
- Works correctly with both root-level and nested paths from custom functions

### Optional: Convenience Helpers

These make manual implementations nicer but aren't strictly required:

```rust
impl ValidationError {
    /// Merge multiple errors at once
    pub fn merge<I>(&mut self, errors: I)
    where
        I: IntoIterator<Item = ValidationError>,
    {
        for error in errors {
            self.extend(error);
        }
    }
}
```

### Path Builder Methods (Already in v0.1)

These are already implemented and work correctly:

```rust
impl Path {
    pub fn root() -> Self;              // Create empty path
    pub fn field(self, name: &'static str) -> Self;  // Append field
    pub fn index(self, idx: usize) -> Self;          // Append index
}
```

**Usage in generated code:**
```rust
// Instead of format!("rooms[{}]", i):
let path = Path::root().field("rooms").index(i);
err.merge_prefixed(path, e);
```

---

## Implementation Tasks

### Phase 1: Project Setup (Week 1, Days 1-2)

#### Task 1.1: Create Workspace
- Convert to workspace layout
- Add domain-model-derive crate
- Update Cargo.toml files
- Ensure v0.1 still builds

#### Task 1.2: Add Dev Dependencies
- Add `trybuild` for compile-fail tests
- Add `syn`, `quote`, `proc-macro2`
- Set up test infrastructure

### Phase 2: Basic Derive Macro (Week 1, Days 3-5)

#### Task 2.1: Parse Struct Definition
- Parse struct with named fields
- Extract field names and types
- Handle visibility, generics (basic)

#### Task 2.2: Parse #[validate(...)] Attributes
- Parse `length(min=N, max=M)`
- Parse `range(min=N, max=M)`
- Parse `nested`
- Store in intermediate representation

#### Task 2.3: Generate Validate Impl (No Attributes)
- Generate basic `impl Validate` skeleton
- Test with struct with no validations
- Ensure it compiles

### Phase 3: Attribute Implementation (Week 2)

#### Task 3.1: Implement `length` Attribute
- Generate code for `String`, `&str`
- Handle min-only, max-only, both
- Custom code/message support
- Tests

#### Task 3.2: Implement `range` Attribute
- Generate code for numeric types
- Type checking (must be PartialOrd)
- Tests for u8, i32, f64

#### Task 3.3: Implement `nested` Attribute
- Basic nested validation
- Handle Option<T>
- Handle Box<T>
- Proper path prefixing

### Phase 4: Collection Validation (Week 3, Days 1-3)

#### Task 4.1: Implement `each(nested)`
- Parse `each(...)` syntax
- Generate indexed iteration
- Path with array indices: `rooms[0].name`

#### Task 4.2: Implement `each(range)` and `each(length)`
- Support primitive validation in collections
- Test with Vec<u8>, Vec<String>

### Phase 5: Custom Validation (Week 3, Days 4-5)

#### Task 5.1: Implement `custom` Attribute
- Parse function path
- Generate function call
- Handle path prefixing
- Validation function signature checking

### Phase 6: Diagnostics (Week 4, Days 1-2)

#### Task 6.1: Type Checking
- Detect range on non-numeric
- Detect length on non-string
- Detect each on non-collection
- Emit compile_error! macros

#### Task 6.2: Trait Bound Checking
- Check nested requires Validate
- Generate helpful error messages

### Phase 7: Testing (Week 4, Days 3-5)

#### Task 7.1: Trybuild Tests
- Compile-fail tests for all error cases
- Golden file tests for expansion

#### Task 7.2: Integration Tests
- Test all attribute types
- Test combinations
- Test path correctness
- Test error accumulation

#### Task 7.3: Examples
- Convert v0.1 examples to use derive
- Add collection validation example
- Add custom validation example

---

## Testing Strategy

### Compile-Fail Tests (trybuild)

```rust
// tests/ui/range_on_string.rs
use domain_model::Validate;

#[derive(Validate)]
struct Bad {
    #[validate(range(min = 1, max = 10))]
    name: String,
}

fn main() {}
```

```text
// tests/ui/range_on_string.stderr
error: #[validate(range)] requires a numeric type
  --> tests/ui/range_on_string.rs:5:5
   |
5  |     #[validate(range(min = 1, max = 10))]
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```

### Expansion Tests

```rust
#[test]
fn test_basic_derive() {
    let t = trybuild::TestCases::new();
    t.pass("tests/expand/basic.rs");
    t.compile_fail("tests/ui/*.rs");
}
```

### Integration Tests

```rust
#[test]
fn test_nested_validation_paths() {
    #[derive(Validate)]
    struct Inner {
        #[validate(length(min = 1))]
        name: String,
    }
    
    #[derive(Validate)]
    struct Outer {
        #[validate(nested)]
        inner: Inner,
    }
    
    let outer = Outer {
        inner: Inner { name: "".to_string() }
    };
    
    let err = outer.validate().unwrap_err();
    assert_eq!(err.violations.len(), 1);
    assert_eq!(err.violations[0].path.to_string(), "inner.name");
}
```

---

## Examples

### Example 1: Basic Derive (v2_basic.rs)

```rust
use domain_model::prelude::*;

#[derive(Debug, Validate)]
struct User {
    #[validate(length(min = 1, max = 50))]
    name: String,
    
    #[validate(range(min = 18, max = 120))]
    age: u8,
}

fn main() {
    let user = User {
        name: "".to_string(),
        age: 15,
    };
    
    match user.validate() {
        Ok(()) => println!("Valid user"),
        Err(e) => {
            println!("Validation failed:");
            for v in &e.violations {
                println!("  [{} {}] {}", v.path, v.code, v.message);
            }
        }
    }
}
```

### Example 2: Nested Validation (v2_nested.rs)

```rust
use domain_model::prelude::*;

#[derive(Debug, Validate)]
struct Email(String);

impl Email {
    pub fn new(s: String) -> Result<Self, ValidationError> {
        validate("email", s.as_str(), rules::email())?;
        Ok(Self(s))
    }
}

#[derive(Debug, Validate)]
struct Guest {
    #[validate(length(min = 1, max = 50))]
    name: String,
    
    #[validate(nested)]
    email: Email,
}

#[derive(Debug, Validate)]
struct Booking {
    #[validate(nested)]
    guest: Guest,
    
    #[validate(range(min = 1, max = 10))]
    guests_count: u8,
}

fn main() {
    let booking = Booking {
        guest: Guest {
            name: "".to_string(),
            email: Email("bad-email".to_string()),
        },
        guests_count: 15,
    };
    
    match booking.validate() {
        Ok(()) => println!("Valid booking"),
        Err(e) => {
            println!("Validation errors:");
            let field_map = e.field_errors_map();
            for (field, messages) in field_map {
                println!("  {}: {:?}", field, messages);
            }
        }
    }
}
```

### Example 3: Collections (v2_collections.rs)

```rust
use domain_model::prelude::*;

#[derive(Debug, Validate)]
struct Room {
    #[validate(range(min = 1, max = 4))]
    adults: u8,
    
    #[validate(range(min = 0, max = 3))]
    children: u8,
}

#[derive(Debug, Validate)]
struct HotelBooking {
    #[validate(length(min = 1))]
    guest_name: String,
    
    #[validate(each(nested))]
    rooms: Vec<Room>,
}

fn main() {
    let booking = HotelBooking {
        guest_name: "John Doe".to_string(),
        rooms: vec![
            Room { adults: 2, children: 1 },
            Room { adults: 5, children: 0 },  // Invalid: too many adults
            Room { adults: 1, children: 4 },  // Invalid: too many children
        ],
    };
    
    match booking.validate() {
        Ok(()) => println!("Valid booking"),
        Err(e) => {
            println!("Found {} errors:", e.violations.len());
            for v in &e.violations {
                println!("  [{}] {}: {}", v.path, v.code, v.message);
            }
        }
    }
}
```

### Example 4: Custom Validation (v2_custom.rs)

```rust
use domain_model::prelude::*;

#[derive(Debug)]
struct DateRange {
    start: String,
    end: String,
}

fn validate_date_range(range: &DateRange) -> Result<(), ValidationError> {
    // Custom logic: ensure end > start
    if range.end <= range.start {
        return Err(ValidationError::single(
            Path::root(),
            "invalid_date_range",
            "End date must be after start date"
        ));
    }
    Ok(())
}

#[derive(Debug, Validate)]
struct Booking {
    #[validate(length(min = 1))]
    guest: String,
    
    #[validate(custom = "validate_date_range")]
    dates: DateRange,
}

fn main() {
    let booking = Booking {
        guest: "John".to_string(),
        dates: DateRange {
            start: "2025-01-15".to_string(),
            end: "2025-01-10".to_string(),
        },
    };
    
    match booking.validate() {
        Ok(()) => println!("Valid"),
        Err(e) => {
            for v in &e.violations {
                println!("[{}] {}", v.path, v.message);
            }
        }
    }
}
```

---

## Success Criteria (Revised)

### Functional Requirements

- ✅ Basic derive works for structs with named fields
- ✅ All 5 attributes implemented: `length`, `range`, `nested`, `each`, `custom`
- ✅ Path prefixing correct for nested and collections (using Path API, not strings)
- ✅ Multiple violations accumulate properly
- ✅ Option<T> and Box<T> handled correctly
- ✅ Structural type checks emit clear compile errors
- ✅ Custom validation uses `.prefixed()` helper correctly

### Testing Requirements (Behavior-Focused)

- ✅ **All attributes covered** by pass + fail tests
- ✅ **All diagnostics** have golden `.stderr` files (trybuild)
- ✅ **All examples** compile and run correctly
- ✅ **Path construction** tested with nested + collection cases
- ✅ **Attribute combinations** tested (allowed + forbidden)
- ✅ **Generated code** inspectable via cargo-expand

**Note:** We measure success by behavior coverage, not code coverage percentages.

### Non-Functional Requirements

- ✅ Compile time < 10s for moderate codebases
- ✅ Generated code is readable (cargo expand)
- ✅ Error messages are actionable
- ✅ Documentation for all attributes with examples

### API Stability

- ✅ No breaking changes to v0.1 API
- ✅ Derive is optional (can still write manual impls)
- ✅ Generated code uses stable v0.1 APIs only
- ✅ Core library additions (`.prefixed()`) are additive

---

## Non-Goals (v0.2)

What we're **explicitly not doing** in v0.2:

❌ Serde integration  
❌ Axum extractors  
❌ error-envelope mapping  
❌ Async validation  
❌ Enum support  
❌ HashSet/HashMap validation  
❌ Tuple structs  
❌ Generics support (beyond basic)  
❌ Conditional validation (when)  
❌ Cross-field validation helpers  

These are v0.3+ features.

---

## Risks & Mitigation

### Risk 1: Proc Macro Complexity

**Risk:** Proc macros are hard to debug and test.

**Mitigation:**
- Start with simplest possible macro
- Add features incrementally
- Use trybuild for compile-fail tests
- Test expansion with cargo-expand

### Risk 2: Error Message Quality

**Risk:** Cryptic errors frustrate users.

**Mitigation:**
- Write compile-fail tests first
- Use `compile_error!` for known issues
- Test error messages with real users
- Iterate based on feedback

### Risk 3: Type System Limitations

**Risk:** Can't perfectly type-check in macro.

**Mitigation:**
- Do basic checks (Vec vs non-Vec)
- Let rustc handle complex cases
- Provide good error messages when rustc fails

---

## Timeline

### Week 1
- **Days 1-2:** Project setup, workspace conversion
- **Days 3-5:** Basic derive macro (no attributes)

### Week 2
- **Days 1-2:** `length` attribute
- **Days 3-4:** `range` attribute  
- **Day 5:** `nested` attribute (basic)

### Week 3
- **Days 1-3:** Collection validation (`each`)
- **Days 4-5:** Custom validation

### Week 4
- **Days 1-2:** Diagnostics and error messages
- **Days 3-5:** Testing, examples, documentation

### Week 5 (Buffer)
- Polish based on self-testing
- Documentation improvements
- Prepare for feedback

---

## Post-v0.2 Roadmap

### v0.3: Service Integration

Pick **one** integration to nail:

**Option A: Axum Integration**
- `ValidatedJson<T>` extractor
- Automatic 400 responses with field errors
- Integration with tower middleware

**Option B: error-envelope Integration**
- `.into_api_error()` on ValidationError
- Field-level error mapping
- HTTP status code selection

**Other v0.3 features:**
- HashSet/HashMap validation
- Tuple struct support
- Basic enum support (field-level only)

### v0.4: Advanced Features

- Async validation
- Cross-field validation helpers
- Conditional validation (when)
- Full generic support

---

## Open Questions (Decide Before Implementation)

### Question 1: Dynamic Path Allocation

**Issue:** `format!("rooms[{}]", i)` allocates.

**Options:**
a) Accept allocation (simplest)
b) Add `Path::push_segment_owned(String)` method
c) Use a small-string optimization

**Decision needed by:** Week 3, Day 1

**Recommendation:** Option (a) for v0.2, optimize in v0.3 if needed

### Question 2: Custom Function Signature

**Issue:** Should custom functions return paths or not?

**Options:**
a) Always return root-level errors, macro prefixes
b) Allow custom functions to set their own paths
c) Support both via two different attributes

**Decision needed by:** Week 3, Day 4

**Recommendation:** Option (b) - macro detects and handles both cases

### Question 3: Generics Support

**Issue:** How much generic support in v0.2?

**Options:**
a) No generics at all
b) Simple generics (no trait bounds checking)
c) Full generic support

**Decision needed by:** Week 1, Day 3

**Recommendation:** Option (b) - generate impl with same bounds as struct

---

## Dependencies

```toml
# domain-model/Cargo.toml (unchanged except version)
[package]
version = "0.2.0"

[dependencies]
regex = { version = "1.10", optional = true }
domain-model-derive = { version = "0.2.0", path = "../domain-model-derive", optional = true }

[features]
default = ["std"]
std = []
email = ["regex"]
derive = ["domain-model-derive"]

# domain-model-derive/Cargo.toml
[dependencies]
syn = { version = "2.0", features = ["full", "extra-traits"] }
quote = "1.0"
proc-macro2 = "1.0"

[dev-dependencies]
trybuild = "1.0"
domain-model = { path = "../domain-model" }
```

---

## Deliverables

### Code
- [ ] domain-model-derive crate with all attributes
- [ ] 4 new examples (basic, nested, collections, custom)
- [ ] 50+ compile-fail tests
- [ ] 100+ integration tests

### Documentation
- [ ] Attribute reference guide
- [ ] Migration guide (v0.1 → v0.2)
- [ ] Generated code examples
- [ ] Troubleshooting guide

### Testing
- [ ] All trybuild tests passing
- [ ] 95%+ macro coverage
- [ ] All examples working
- [ ] No clippy warnings

---

## V0.2 Stable Contract

This is what we're committing to for v0.2. No scope creep beyond this.

### Attributes (Exactly These 5)

1. **`length(min=?, max=?, code=?, message=?)`**
   - For: `String`, `&str`, `Cow<'_, str>`
   - Generates: `rules::min_len().and(rules::max_len())`

2. **`range(min=?, max=?, code=?, message=?)`**
   - For: Types implementing `PartialOrd + Copy + Display`
   - Generates: `rules::range(min, max)`

3. **`nested`**
   - For: `T: Validate`, `Option<T>`, `Box<T>`
   - Generates: `.validate()` call with path prefixing

4. **`each(nested | length(...) | range(...))`**
   - For: `Vec<T>` only (v0.2)
   - Generates: Loop with indexed paths: `field[i]`

5. **`custom = "path::to::fn"`**
   - For: Any type
   - Function signature: `fn(&T) -> Result<(), ValidationError>`
   - Generates: Function call with `.prefixed()` wrapper

### Attribute Combinations

- `custom` can combine with `length`, `range`, `nested` (✅)
- `each` is exclusive - cannot combine (❌)
- All other combinations forbidden (❌)

### Type Checking Strategy

**Macro checks (compile_error!):**
- Is it `Vec<T>`? (for `each`)
- Is it `String`/`&str`/`Cow`? (for `length`)

**Rustc checks (let it error naturally):**
- Trait bounds (`PartialOrd`, `Validate`, etc.)
- Generic constraints
- Type compatibility

### Core Library Requirements

**Must add to v0.1:**
```rust
impl ValidationError {
    pub fn prefixed(self, prefix: impl Into<Path>) -> Self;
}
```

**Already exists (use as-is):**
```rust
impl Path {
    pub fn root() -> Self;
    pub fn field(self, name: &'static str) -> Self;
    pub fn index(self, idx: usize) -> Self;
}
```

### Generated Code Pattern

```rust
impl Validate for MyStruct {
    fn validate(&self) -> Result<(), ValidationError> {
        let mut err = ValidationError::default();
        
        // Pattern 1: Basic rule
        let rule = rules::min_len(1).and(rules::max_len(50));
        if let Err(e) = validate("field", &self.field.as_str(), &rule) {
            err.extend(e);
        }
        
        // Pattern 2: Nested
        if let Err(e) = self.nested.validate() {
            err.merge_prefixed("nested", e);
        }
        
        // Pattern 3: Collection
        for (i, item) in self.items.iter().enumerate() {
            if let Err(e) = item.validate() {
                let path = Path::root().field("items").index(i);
                err.merge_prefixed(path, e);
            }
        }
        
        // Pattern 4: Custom
        if let Err(e) = custom_fn(&self.field) {
            err.extend(e.prefixed("field"));
        }
        
        if err.is_empty() { Ok(()) } else { Err(err) }
    }
}
```

### What We're NOT Doing

❌ Serde integration  
❌ Axum extractors  
❌ Async validation  
❌ Enum support  
❌ Tuple structs  
❌ HashSet/HashMap (Vec only)  
❌ Cross-field validation  
❌ Conditional validation (`when`)  
❌ Complex generics (basic only)

---

**Last Updated:** 2025-12-23 (Revised with feedback - ready for implementation)
