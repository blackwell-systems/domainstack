# domain-model v0.1 Implementation Plan

**Status:** Planning  
**Target Completion:** 2-3 weeks  
**Focus:** Core validation types and rule algebra (no macros)

---

## v0.1 Scope

From CONCEPT.md:
- Core types: `ValidationError`, `Violation`, `Path` with full API
- `Rule<T>` with `and`, `or`, `when` combinators
- Built-in rules: `email`, `min_len`, `max_len`, `range`, `non_empty`
- `validate()` helper function
- Manual domain type pattern (no macros yet)
- Basic tests and examples

**Goal:** Validate the core design with real users before investing in macros.

---

## Module Structure

```text
domain-model/
├── Cargo.toml
├── src/
│   ├── lib.rs              # Re-exports + documentation
│   ├── path.rs             # Path, PathSegment, Display impl
│   ├── violation.rs        # Violation, Meta
│   ├── error.rs            # ValidationError with full API
│   ├── validate.rs         # Validate trait
│   ├── rule.rs             # Rule<T> algebra
│   ├── rules/
│   │   ├── mod.rs          # Re-exports
│   │   ├── string.rs       # email, min_len, max_len, non_empty
│   │   └── numeric.rs      # range
│   ├── prelude.rs          # Convenient re-exports
│   └── helpers.rs          # validate() function
├── tests/
│   ├── path_tests.rs
│   ├── error_tests.rs
│   ├── rule_tests.rs
│   ├── string_rules_tests.rs
│   ├── numeric_rules_tests.rs
│   └── integration_tests.rs
└── examples/
    ├── email_primitive.rs
    ├── age_primitive.rs
    └── booking_aggregate.rs
```

---

## Implementation Tasks

### Phase 1: Core Types (Week 1, Days 1-2)

#### Task 1.1: Path Implementation
**File:** `src/path.rs`  
**Estimate:** 2 hours

```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Path(pub Vec<PathSegment>);

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PathSegment {
    Field(&'static str),
    Index(usize),
}

impl Path {
    pub fn root() -> Self { Self(Vec::new()) }
    
    pub fn field(mut self, name: &'static str) -> Self {
        self.0.push(PathSegment::Field(name));
        self
    }
    
    pub fn index(mut self, idx: usize) -> Self {
        self.0.push(PathSegment::Index(idx));
        self
    }
    
    pub fn parse(s: &str) -> Self {
        // Simple parser: split on '.' and '[', ']'
        // v0.1: Basic implementation, improve in v0.2
        todo!("Implement basic parser")
    }
}

impl core::fmt::Display for Path {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        for (i, segment) in self.0.iter().enumerate() {
            match segment {
                PathSegment::Field(name) => {
                    if i > 0 { write!(f, ".")?; }
                    write!(f, "{}", name)?;
                }
                PathSegment::Index(idx) => write!(f, "[{}]", idx)?,
            }
        }
        Ok(())
    }
}

impl From<&'static str> for Path {
    fn from(s: &'static str) -> Self {
        Path(vec![PathSegment::Field(s)])
    }
}

impl From<String> for Path {
    fn from(s: String) -> Self {
        Path::parse(&s)
    }
}
```

**Tests:**
- root() creates empty path
- field() appends field segment
- index() appends index segment
- Display formats correctly: "field.nested[0].item"
- From<&str> creates single-field path
- parse() handles basic cases (defer complex parsing)

#### Task 1.2: Violation Implementation
**File:** `src/violation.rs`  
**Estimate:** 1 hour

```rust
use crate::Path;

#[derive(Debug, Clone)]
pub struct Violation {
    pub path: Path,
    pub code: &'static str,
    pub message: String,
    pub meta: Meta,
}

#[derive(Debug, Clone, Default)]
pub struct Meta {
    // v0.1: Keep simple, no serde_json dependency yet
    // Store as Vec<(key, value)> for now
    fields: Vec<(&'static str, String)>,
}

impl Meta {
    pub fn new() -> Self {
        Self { fields: Vec::new() }
    }
    
    pub fn insert(&mut self, key: &'static str, value: impl ToString) {
        self.fields.push((key, value.to_string()));
    }
    
    pub fn get(&self, key: &'static str) -> Option<&str> {
        self.fields.iter()
            .find(|(k, _)| *k == key)
            .map(|(_, v)| v.as_str())
    }
}
```

**Tests:**
- Violation creation
- Meta insert/get
- Meta defaults to empty

#### Task 1.3: ValidationError Implementation
**File:** `src/error.rs`  
**Estimate:** 3 hours

```rust
use crate::{Path, Violation};
use std::collections::BTreeMap;

#[derive(Debug, Clone, Default)]
pub struct ValidationError {
    pub violations: Vec<Violation>,
}

impl ValidationError {
    pub fn new() -> Self {
        Self { violations: Vec::new() }
    }
    
    pub fn is_empty(&self) -> bool {
        self.violations.is_empty()
    }
    
    /// Create a ValidationError with a single violation
    pub fn single(
        path: impl Into<Path>,
        code: &'static str,
        message: impl Into<String>,
    ) -> Self {
        let mut err = Self::new();
        err.push(path, code, message);
        err
    }
    
    pub fn push(
        &mut self,
        path: impl Into<Path>,
        code: &'static str,
        message: impl Into<String>,
    ) {
        self.violations.push(Violation {
            path: path.into(),
            code,
            message: message.into(),
            meta: Meta::default(),
        });
    }
    
    pub fn extend(&mut self, other: ValidationError) {
        self.violations.extend(other.violations);
    }
    
    pub fn merge_prefixed(&mut self, prefix: impl Into<Path>, other: ValidationError) {
        let prefix = prefix.into();
        for mut violation in other.violations {
            // Prepend prefix segments to existing path
            let mut new_segments = prefix.0.clone();
            new_segments.extend(violation.path.0);
            violation.path = Path(new_segments);
            self.violations.push(violation);
        }
    }
    
    pub fn field_errors_map(&self) -> BTreeMap<String, Vec<String>> {
        let mut map = BTreeMap::new();
        for violation in &self.violations {
            map.entry(violation.path.to_string())
                .or_insert_with(Vec::new)
                .push(violation.message.clone());
        }
        map
    }
}

impl std::fmt::Display for ValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.violations.is_empty() {
            write!(f, "No validation errors")
        } else if self.violations.len() == 1 {
            write!(f, "Validation error: {}", self.violations[0].message)
        } else {
            write!(f, "Validation failed with {} errors", self.violations.len())
        }
    }
}

impl std::error::Error for ValidationError {}
```

**Tests:**
- new() and default()
- is_empty()
- single() creates with one violation
- push() adds violations
- extend() merges violations
- merge_prefixed() correctly prepends path segments
- field_errors_map() groups by path
- Display formatting

#### Task 1.4: Validate Trait
**File:** `src/validate.rs`  
**Estimate:** 30 minutes

```rust
use crate::ValidationError;

/// Synchronous validation trait
pub trait Validate {
    fn validate(&self) -> Result<(), ValidationError>;
}
```

**Tests:**
- Manual implementation on test struct
- Verify trait can be imported

---

### Phase 2: Rule Algebra (Week 1, Days 3-4)

#### Task 2.1: Rule Core
**File:** `src/rule.rs`  
**Estimate:** 4 hours

```rust
use crate::ValidationError;
use std::sync::Arc;

/// Composable validation rule
pub struct Rule<T> {
    inner: Arc<dyn Fn(&T) -> ValidationError + Send + Sync>,
}

impl<T> Clone for Rule<T> {
    fn clone(&self) -> Self {
        Self {
            inner: Arc::clone(&self.inner),
        }
    }
}

impl<T> Rule<T> {
    /// Create a new rule from a function
    pub fn new<F>(f: F) -> Self
    where
        F: Fn(&T) -> ValidationError + Send + Sync + 'static,
    {
        Self {
            inner: Arc::new(f),
        }
    }
    
    /// Apply the rule to a value
    pub fn apply(&self, value: &T) -> ValidationError {
        (self.inner)(value)
    }
    
    /// Combine two rules (both must pass)
    pub fn and(self, other: Rule<T>) -> Rule<T> {
        Rule::new(move |value| {
            let mut err = self.apply(value);
            err.extend(other.apply(value));
            err
        })
    }
    
    /// Either rule can pass
    pub fn or(self, other: Rule<T>) -> Rule<T> {
        Rule::new(move |value| {
            let err1 = self.apply(value);
            if err1.is_empty() {
                return err1;
            }
            let err2 = other.apply(value);
            if err2.is_empty() {
                return err2;
            }
            // Both failed, return union of errors
            let mut combined = err1;
            combined.extend(err2);
            combined
        })
    }
    
    /// Negate the rule
    pub fn not(self, code: &'static str, message: &'static str) -> Rule<T> {
        Rule::new(move |value| {
            let err = self.apply(value);
            if err.is_empty() {
                // Rule passed, NOT fails
                ValidationError::single(Path::root(), code, message)
            } else {
                // Rule failed, NOT passes
                ValidationError::default()
            }
        })
    }
    
    /// Prefix all error paths
    pub fn map_path(self, prefix: impl Into<Path> + Clone + Send + Sync + 'static) -> Rule<T> {
        Rule::new(move |value| {
            let err = self.apply(value);
            if err.is_empty() {
                return err;
            }
            let mut prefixed = ValidationError::default();
            prefixed.merge_prefixed(prefix.clone(), err);
            prefixed
        })
    }
    
    /// Conditionally apply the rule
    pub fn when<F>(self, predicate: F) -> Rule<T>
    where
        F: Fn() -> bool + Send + Sync + 'static,
    {
        Rule::new(move |value| {
            if predicate() {
                self.apply(value)
            } else {
                ValidationError::default()
            }
        })
    }
}
```

**Tests:**
- new() creates rule
- apply() executes rule
- and() combines rules (both run, errors concatenate)
- or() returns first success or union of failures
- not() inverts rule
- map_path() prefixes error paths
- when() conditionally applies rule

#### Task 2.2: Validation Helper
**File:** `src/helpers.rs`  
**Estimate:** 1 hour

```rust
use crate::{Path, Rule, ValidationError};

/// Validate a value against a rule with path context
pub fn validate<T>(
    path: impl Into<Path>,
    value: &T,
    rule: Rule<T>,
) -> Result<(), ValidationError> {
    let mut err = rule.apply(value);
    
    if err.is_empty() {
        Ok(())
    } else {
        // Prefix errors with the given path
        let mut prefixed = ValidationError::default();
        prefixed.merge_prefixed(path, err);
        Err(prefixed)
    }
}
```

**Tests:**
- validate() with passing rule returns Ok
- validate() with failing rule returns Err
- validate() prefixes error paths correctly

---

### Phase 3: Built-in Rules (Week 1, Day 5 - Week 2, Day 1)

#### Task 3.1: String Rules
**File:** `src/rules/string.rs`  
**Estimate:** 4 hours

```rust
use crate::{Rule, ValidationError, Path};

/// Email validation rule
pub fn email() -> Rule<&str> {
    Rule::new(|value: &&str| {
        // Basic email regex: .+@.+\..+
        let re = regex::Regex::new(r"^[^@\s]+@[^@\s]+\.[^@\s]+$").unwrap();
        
        if re.is_match(value) {
            ValidationError::default()
        } else {
            ValidationError::single(
                Path::root(),
                "invalid_email",
                "Invalid email format"
            )
        }
    })
}

/// Non-empty string rule
pub fn non_empty() -> Rule<&str> {
    Rule::new(|value: &&str| {
        if value.is_empty() {
            let mut err = ValidationError::single(
                Path::root(),
                "non_empty",
                "Must not be empty"
            );
            err
        } else {
            ValidationError::default()
        }
    })
}

/// Minimum length rule
pub fn min_len(min: usize) -> Rule<&str> {
    Rule::new(move |value: &&str| {
        if value.len() < min {
            let mut err = ValidationError::single(
                Path::root(),
                "min_length",
                format!("Must be at least {} characters", min)
            );
            // Add meta for context
            err.violations[0].meta.insert("min", min.to_string());
            err
        } else {
            ValidationError::default()
        }
    })
}

/// Maximum length rule
pub fn max_len(max: usize) -> Rule<&str> {
    Rule::new(move |value: &&str| {
        if value.len() > max {
            let mut err = ValidationError::single(
                Path::root(),
                "max_length",
                format!("Must be at most {} characters", max)
            );
            err.violations[0].meta.insert("max", max.to_string());
            err
        } else {
            ValidationError::default()
        }
    })
}

/// Length range rule (convenience combinator)
pub fn length(min: usize, max: usize) -> Rule<&str> {
    min_len(min).and(max_len(max))
}
```

**Tests:**
- email() accepts valid emails
- email() rejects invalid formats
- non_empty() rejects empty strings
- min_len() checks minimum length
- max_len() checks maximum length
- length() combines min and max
- Meta fields are set correctly

#### Task 3.2: Numeric Rules
**File:** `src/rules/numeric.rs`  
**Estimate:** 2 hours

```rust
use crate::{Rule, ValidationError, Path};

/// Range validation rule
pub fn range<T>(min: T, max: T) -> Rule<T>
where
    T: PartialOrd + Copy + std::fmt::Display + Send + Sync + 'static,
{
    Rule::new(move |value: &T| {
        if *value < min || *value > max {
            let mut err = ValidationError::single(
                Path::root(),
                "out_of_range",
                format!("Must be between {} and {}", min, max)
            );
            err.violations[0].meta.insert("min", min.to_string());
            err.violations[0].meta.insert("max", max.to_string());
            err
        } else {
            ValidationError::default()
        }
    })
}

/// Minimum value rule
pub fn min<T>(min: T) -> Rule<T>
where
    T: PartialOrd + Copy + std::fmt::Display + Send + Sync + 'static,
{
    Rule::new(move |value: &T| {
        if *value < min {
            let mut err = ValidationError::single(
                Path::root(),
                "below_minimum",
                format!("Must be at least {}", min)
            );
            err.violations[0].meta.insert("min", min.to_string());
            err
        } else {
            ValidationError::default()
        }
    })
}

/// Maximum value rule
pub fn max<T>(max: T) -> Rule<T>
where
    T: PartialOrd + Copy + std::fmt::Display + Send + Sync + 'static,
{
    Rule::new(move |value: &T| {
        if *value > max {
            let mut err = ValidationError::single(
                Path::root(),
                "above_maximum",
                format!("Must be at most {}", max)
            );
            err.violations[0].meta.insert("max", max.to_string());
            err
        } else {
            ValidationError::default()
        }
    })
}
```

**Tests:**
- range() validates numeric ranges (u8, u32, i32, f64)
- min() checks minimum value
- max() checks maximum value
- Meta fields are populated

#### Task 3.3: Rules Module
**File:** `src/rules/mod.rs`  
**Estimate:** 30 minutes

```rust
pub mod string;
pub mod numeric;

// Re-export commonly used rules
pub use string::{email, non_empty, min_len, max_len, length};
pub use numeric::{range, min, max};
```

---

### Phase 4: Integration & Polish (Week 2, Days 2-3)

#### Task 4.1: Prelude Module
**File:** `src/prelude.rs`  
**Estimate:** 30 minutes

```rust
pub use crate::{
    Validate,
    ValidationError,
    Violation,
    Path,
    PathSegment,
    Rule,
    rules,
    validate,
};
```

#### Task 4.2: Lib.rs Documentation
**File:** `src/lib.rs`  
**Estimate:** 2 hours

```rust
//! # domain-model
//!
//! A Rust validation framework for domain-driven design.
//!
//! ## Quick Start
//!
//! ```rust
//! use domain_model::prelude::*;
//!
//! // Define domain primitive
//! struct Email(String);
//!
//! impl Email {
//!     pub fn new(raw: String) -> Result<Self, ValidationError> {
//!         validate("email", &raw.as_str(), rules::email())?;
//!         Ok(Self(raw))
//!     }
//! }
//! ```
//!
//! ## Features
//!
//! - **Valid-by-construction types** - Invalid states can't exist
//! - **Composable rules** - Combine validation logic with `and`, `or`, `when`
//! - **Structured error paths** - Field-level error reporting
//! - **Zero dependencies** - Core crate uses only std
//!
//! ## Usage
//!
//! See examples/ directory for complete examples.

mod path;
mod violation;
mod error;
mod validate;
mod rule;
mod helpers;

pub mod rules;
pub mod prelude;

pub use path::{Path, PathSegment};
pub use violation::{Violation, Meta};
pub use error::ValidationError;
pub use validate::Validate;
pub use rule::Rule;
pub use helpers::validate;
```

#### Task 4.3: Cargo.toml
**File:** `Cargo.toml`  
**Estimate:** 30 minutes

```toml
[package]
name = "domain-model"
version = "0.1.0"
edition = "2021"
rust-version = "1.65"  # Required for GAT (even though not used in v0.1)
authors = ["Blackwell Systems"]
license = "Apache 2.0"
description = "Domain validation framework for Rust services"
repository = "https://github.com/blackwell-systems/domain-model"
documentation = "https://docs.rs/domain-model"
keywords = ["validation", "domain", "ddd", "api", "web"]
categories = ["web-programming", "data-structures"]

[dependencies]
regex = { version = "1.10", optional = true }

[features]
default = ["std"]
std = []
email = ["regex"]  # Email validation requires regex

[dev-dependencies]
# For testing only
```

---

### Phase 5: Examples (Week 2, Days 4-5)

#### Task 5.1: Email Primitive Example
**File:** `examples/email_primitive.rs`  
**Estimate:** 1 hour

```rust
use domain_model::prelude::*;

#[derive(Debug, Clone)]
pub struct Email(String);

impl Email {
    pub fn new(raw: impl Into<String>) -> Result<Self, ValidationError> {
        let raw = raw.into();
        validate("email", &raw.as_str(), rules::email().and(rules::max_len(255)))?;
        Ok(Self(raw))
    }
    
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl Validate for Email {
    fn validate(&self) -> Result<(), ValidationError> {
        validate("email", self.0.as_str(), rules::email().and(rules::max_len(255)))
    }
}

fn main() {
    // Valid email
    match Email::new("user@example.com") {
        Ok(email) => println!("Valid: {}", email.as_str()),
        Err(e) => println!("Error: {}", e),
    }
    
    // Invalid email
    match Email::new("not-an-email") {
        Ok(_) => println!("Unexpected success"),
        Err(e) => {
            println!("Validation failed:");
            for v in &e.violations {
                println!("  [{}] {}: {}", v.path, v.code, v.message);
            }
        }
    }
    
    // Too long email
    match Email::new("a".repeat(300) + "@example.com") {
        Ok(_) => println!("Unexpected success"),
        Err(e) => {
            println!("Multiple violations:");
            for v in &e.violations {
                println!("  [{}] {}: {}", v.path, v.code, v.message);
            }
        }
    }
}
```

#### Task 5.2: Age Primitive Example
**File:** `examples/age_primitive.rs`  
**Estimate:** 1 hour

```rust
use domain_model::prelude::*;

#[derive(Debug, Clone, Copy)]
pub struct Age(u8);

impl Age {
    pub fn new(value: u8) -> Result<Self, ValidationError> {
        validate("age", &value, rules::range(18, 120))?;
        Ok(Self(value))
    }
    
    pub fn value(&self) -> u8 {
        self.0
    }
}

impl Validate for Age {
    fn validate(&self) -> Result<(), ValidationError> {
        validate("age", &self.0, rules::range(18, 120))
    }
}

fn main() {
    // Valid ages
    for age in [18, 25, 65, 120] {
        match Age::new(age) {
            Ok(a) => println!("Valid age: {}", a.value()),
            Err(e) => println!("Error: {}", e),
        }
    }
    
    // Invalid ages
    for age in [0, 17, 121, 255] {
        match Age::new(age) {
            Ok(_) => println!("Unexpected success for {}", age),
            Err(e) => {
                println!("Age {} rejected:", age);
                for v in &e.violations {
                    println!("  {}: {}", v.code, v.message);
                }
            }
        }
    }
}
```

#### Task 5.3: Booking Aggregate Example
**File:** `examples/booking_aggregate.rs`  
**Estimate:** 2 hours

```rust
use domain_model::prelude::*;

// Reuse Email and Age from above (or inline for example)
#[derive(Debug, Clone)]
pub struct Email(String);
impl Email {
    pub fn new(raw: String) -> Result<Self, ValidationError> {
        validate("email", &raw.as_str(), rules::email())?;
        Ok(Self(raw))
    }
}
impl Validate for Email {
    fn validate(&self) -> Result<(), ValidationError> {
        validate("email", self.0.as_str(), rules::email())
    }
}

// Guest aggregate
#[derive(Debug)]
pub struct Guest {
    pub name: String,
    pub email: Email,
}

impl Guest {
    pub fn new(name: String, email: Email) -> Result<Self, ValidationError> {
        let guest = Self { name, email };
        guest.validate()?;
        Ok(guest)
    }
}

impl Validate for Guest {
    fn validate(&self) -> Result<(), ValidationError> {
        let mut err = ValidationError::default();
        
        // Validate name length
        if let Err(e) = validate("name", &self.name.as_str(), rules::min_len(1).and(rules::max_len(50))) {
            err.extend(e);
        }
        
        // Validate nested email
        if let Err(e) = self.email.validate() {
            err.merge_prefixed("email", e);
        }
        
        if err.is_empty() { Ok(()) } else { Err(err) }
    }
}

// Booking aggregate with nested guest
#[derive(Debug)]
pub struct BookingRequest {
    pub guest: Guest,
    pub guests_count: u8,
}

impl BookingRequest {
    pub fn new(guest: Guest, guests_count: u8) -> Result<Self, ValidationError> {
        let booking = Self { guest, guests_count };
        booking.validate()?;
        Ok(booking)
    }
}

impl Validate for BookingRequest {
    fn validate(&self) -> Result<(), ValidationError> {
        let mut err = ValidationError::default();
        
        // Validate guest count
        if let Err(e) = validate("guests_count", &self.guests_count, rules::range(1, 10)) {
            err.extend(e);
        }
        
        // Validate nested guest
        if let Err(e) = self.guest.validate() {
            err.merge_prefixed("guest", e);
        }
        
        if err.is_empty() { Ok(()) } else { Err(err) }
    }
}

fn main() {
    // Valid booking
    let email = Email::new("john@example.com".to_string()).unwrap();
    let guest = Guest::new("John Doe".to_string(), email).unwrap();
    let booking = BookingRequest::new(guest, 2).unwrap();
    
    println!("Valid booking: {:?}", booking);
    
    // Invalid booking (bad email, too many guests)
    match Email::new("not-an-email".to_string()) {
        Ok(email) => {
            let guest = Guest::new("".to_string(), email).unwrap_or_else(|e| {
                println!("Guest validation failed:");
                for v in &e.violations {
                    println!("  [{}] {}: {}", v.path, v.code, v.message);
                }
                panic!();
            });
            
            match BookingRequest::new(guest, 15) {
                Ok(_) => println!("Unexpected success"),
                Err(e) => {
                    println!("Booking validation failed:");
                    for v in &e.violations {
                        println!("  [{}] {}: {}", v.path, v.code, v.message);
                    }
                }
            }
        }
        Err(e) => {
            println!("Email validation failed:");
            for v in &e.violations {
                println!("  [{}] {}: {}", v.path, v.code, v.message);
            }
        }
    }
}
```

---

### Phase 6: Testing (Week 2, Days 6-7)

#### Task 6.1: Unit Tests
**Estimate:** 6 hours

**Coverage targets:**
- `path.rs`: 100% (construction, display, from impls)
- `violation.rs`: 100% (violation creation, meta operations)
- `error.rs`: 100% (all methods, edge cases)
- `rule.rs`: 100% (all combinators)
- `rules/string.rs`: 100% (all string rules)
- `rules/numeric.rs`: 100% (all numeric rules)
- `helpers.rs`: 100% (validate function)

**Test categories:**
1. Happy path tests
2. Error path tests
3. Edge cases (empty, maximum size)
4. Combinator tests (and, or, not, when)
5. Path prefixing tests

#### Task 6.2: Integration Tests
**File:** `tests/integration_tests.rs`  
**Estimate:** 3 hours

```rust
use domain_model::prelude::*;

#[test]
fn test_email_primitive() {
    // Valid
    let email = Email::new("test@example.com".to_string());
    assert!(email.is_ok());
    
    // Invalid
    let email = Email::new("not-an-email".to_string());
    assert!(email.is_err());
    let err = email.unwrap_err();
    assert_eq!(err.violations.len(), 1);
    assert_eq!(err.violations[0].code, "invalid_email");
}

#[test]
fn test_nested_validation() {
    // Test that nested errors get proper paths
    // guest.email, guest.name, etc.
}

#[test]
fn test_rule_composition() {
    // Test and, or, not, when combinators
}

#[test]
fn test_field_errors_map() {
    // Test grouping violations by path
}
```

#### Task 6.3: Documentation Tests
**Estimate:** 2 hours

Add doc tests to all public APIs:
- Trait definitions
- Core types
- Rule constructors
- Helper functions

---

## Dependencies

### v0.1 Dependencies

```toml
[dependencies]
regex = { version = "1.10", optional = true }

[features]
email = ["regex"]
```

**Rationale:**
- **regex** - Only for email validation, feature-gated
- **No other dependencies** - Keep core minimal

### Dev Dependencies

```toml
[dev-dependencies]
# None needed for v0.1
```

---

## Testing Strategy

### Unit Test Coverage
- Minimum 95% coverage for all modules
- Use `cargo tarpaulin` or `cargo llvm-cov`

### Property-Based Testing
- Consider `proptest` for Rule combinators (v0.2)
- Defer for v0.1 (keep it simple)

### Integration Tests
- Real-world domain primitives (Email, Age, Username)
- Nested structs with path prefixing
- Rule composition patterns

### Documentation Tests
- All public APIs have working examples
- Examples compile and pass

---

## Success Criteria

### Functional Requirements
- [ ] Can create Email primitive with validation
- [ ] Can create Age primitive with range validation
- [ ] Can compose rules with and/or/when
- [ ] Can nest validations with proper path prefixing
- [ ] Error messages are clear and actionable
- [ ] field_errors_map() returns correct structure

### Non-Functional Requirements
- [ ] Compile time < 5s for examples
- [ ] All tests pass
- [ ] 95%+ test coverage
- [ ] Documentation builds without warnings
- [ ] No unsafe code
- [ ] No panics in library code

### API Stability
- [ ] Core API is minimal and stable
- [ ] Types can be extended without breaking changes
- [ ] Rules can be added in v0.2 without API breaks

---

## Timeline

### Week 1
- **Day 1-2:** Phase 1 - Core types (Path, Violation, ValidationError)
- **Day 3-4:** Phase 2 - Rule algebra
- **Day 5:** Phase 3 - String rules

### Week 2
- **Day 1:** Phase 3 - Numeric rules
- **Day 2-3:** Phase 4 - Integration & documentation
- **Day 4-5:** Phase 5 - Examples
- **Day 6-7:** Phase 6 - Testing

### Week 3 (Buffer)
- Polish documentation
- Address any issues from testing
- Prepare for v0.2 (derive macro planning)

---

## Risks

### Week 1 Risks
- **Path API design** - May need iteration to get ergonomics right
- **Rule closure lifetimes** - Arc<dyn Fn> might have lifetime issues

**Mitigation:** Start with simplest cases, add complexity incrementally.

### Week 2 Risks
- **Meta field design** - Might be too simple or too complex
- **Error message quality** - Hard to get right without user feedback

**Mitigation:** Get feedback from 2-3 early users before finalizing.

---

## Open Questions for v0.1

1. **Meta field representation**
   - Current: `Vec<(&'static str, String)>`
   - Alternative: Wait for serde_json feature?
   - **Decision needed by:** Day 2

2. **Path::parse() complexity**
   - Current: Defer complex parsing to v0.2
   - Alternative: Implement full parser now
   - **Decision needed by:** Day 1

3. **Error Display format**
   - Current: Simple message
   - Alternative: Multi-line with all violations
   - **Decision needed by:** Day 3

4. **Rule<T> interior mutability**
   - Current: Immutable (Arc)
   - Alternative: Allow stateful rules?
   - **Decision needed by:** Day 4

---

## Deliverables

### Code
- [ ] `domain-model` crate with all modules
- [ ] 3 complete examples
- [ ] 100+ unit tests
- [ ] Integration test suite

### Documentation
- [ ] README.md with quick start
- [ ] API documentation (rustdoc)
- [ ] Examples documentation
- [ ] CHANGELOG.md

### Testing
- [ ] All tests passing
- [ ] 95%+ coverage
- [ ] No compiler warnings
- [ ] Clippy clean

---

## Next Steps After v0.1

1. **Get feedback** - Share with 3-5 Rust developers
2. **Identify pain points** - What's hard to use?
3. **Plan v0.2** - Design derive macro based on v0.1 usage
4. **Write blog post** - "Introducing domain-model v0.1"

---

**Last Updated:** 2025-12-23
