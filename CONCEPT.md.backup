# domain-model: Rust Domain Validation Framework

**Status:** Concept / Pre-Development  
**Type:** Rust Library (Crate)  
**Target Audience:** Service-oriented Rust applications (Axum, Actix, etc.)

---

## Problem Statement

Rust services need a unified approach to domain modeling and validation that:

1. **Enforces valid-by-construction types** (invalid states are unrepresentable)
2. **Provides structured, field-level error reporting** for APIs
3. **Supports both sync and async validation** (format checks + DB uniqueness checks)
4. **Integrates with the Rust HTTP ecosystem** (serde, axum, error_envelope)
5. **Uses composable validation rules** (not just attributes)

### Current Ecosystem Gaps

| Crate | Strength | Weakness |
|-------|----------|----------|
| `validator` | Attribute-based validation | DTO-first, no domain modeling |
| `garde` | Good nested validation | Still DTO-focused, no async |
| `nutype` | Valid-by-construction newtypes | Only primitives, no aggregates |
| `serde_valid` | Validate-on-deserialize | Couples validation to serialization |

**None provide:**
- Domain-first design (DTO → Domain boundary)
- Composable rule algebra (`and`, `or`, `when`)
- Async validation with context
- First-class integration with API error envelopes

---

## Design Philosophy

### 1. Valid-by-Construction Domain Types

```rust
// ❌ Current: Any string accepted
#[derive(Deserialize)]
struct Guest {
    email: String,  // Could be "not-an-email"
}

// ✓ Domain model: Invalid states prevented
struct Guest {
    email: Email,  // Guaranteed valid email
}

impl Guest {
    pub fn new(email: Email) -> Result<Self, ValidationError> {
        Ok(Self { email })
    }
}
```

### 2. DTO → Domain Boundary

```rust
// HTTP boundary: DTOs for deserialization
#[derive(Deserialize)]
struct GuestDto {
    email: String,
}

// Domain boundary: Smart constructors
impl TryFrom<GuestDto> for Guest {
    type Error = ValidationError;
    
    fn try_from(dto: GuestDto) -> Result<Self, Self::Error> {
        Guest::new(Email::new(dto.email)?)
    }
}
```

**Why:** Keeps serde concerns separate from domain logic.

### 3. Structured Error Paths

```rust
// Single error type, multiple outputs
pub struct ValidationError {
    pub violations: Vec<Violation>,
}

pub struct Violation {
    pub path: Path,              // "guest.email", "rooms[0].adults"
    pub code: &'static str,       // Stable identifier: "invalid_email"
    pub message: String,          // Human message
    pub meta: Meta,               // Optional: {min: 3, max: 50}
}
```

**Result:**
```json
{
  "code": "VALIDATION_FAILED",
  "details": {
    "fields": {
      "guest.email": ["Invalid email format"],
      "rooms[0].adults": ["Must be between 1 and 6"]
    }
  }
}
```

### 4. Composable Validation Rules

```rust
// Rules are first-class values
let email_rule = rules::email()
    .and(rules::max_len(255))
    .map_path("contact");

// Reuse across types
validate("email", &value, email_rule)?;
```

**Why:** More powerful than attributes alone—rules can be stored, composed, tested independently.

---

## Public API Design

### Core Traits

```rust
/// Synchronous validation (format, range, length)
pub trait Validate {
    fn validate(&self) -> Result<(), ValidationError>;
}

/// Asynchronous validation (DB checks, external APIs)
pub trait AsyncValidate<Ctx> {
    type Fut<'a>: Future<Output = Result<(), ValidationError>> + Send + 'a
    where Self: 'a, Ctx: 'a;
    
    fn validate_async<'a>(&'a self, ctx: &'a Ctx) -> Self::Fut<'a>;
}
```

### Core Types

```rust
/// Structured path to a field
pub struct Path(Vec<PathSegment>);

pub enum PathSegment {
    Field(&'static str),  // .email
    Index(usize),         // [0]
}

/// Single validation violation
pub struct Violation {
    pub path: Path,
    pub code: &'static str,
    pub message: String,
    pub meta: Meta,
}

/// Collection of violations
pub struct ValidationError {
    pub violations: Vec<Violation>,
}

impl ValidationError {
    pub fn push(&mut self, path: impl Into<Path>, code: &'static str, message: impl Into<String>);
    pub fn merge_prefixed(&mut self, prefix: impl Into<Path>, other: ValidationError);
    pub fn field_errors_map(&self) -> BTreeMap<String, Vec<Violation>>;
}
```

### Rule Algebra

```rust
pub struct Rule<T>(Arc<dyn Fn(&T) -> ValidationError + Send + Sync>);

impl<T> Rule<T> {
    pub fn and(self, other: Rule<T>) -> Rule<T>;
    pub fn or(self, other: Rule<T>) -> Rule<T>;
    pub fn not(self, code: &'static str, message: &'static str) -> Rule<T>;
    pub fn map_path(self, prefix: impl Into<Path>) -> Rule<T>;
    pub fn when(self, predicate: impl Fn() -> bool + Send + Sync + 'static) -> Rule<T>;
}
```

### Built-in Rules

```rust
pub mod rules {
    pub fn email() -> Rule<&str>;
    pub fn non_empty() -> Rule<&str>;
    pub fn min_len(n: usize) -> Rule<&str>;
    pub fn max_len(n: usize) -> Rule<&str>;
    pub fn range<T: PartialOrd + Copy>(min: T, max: T) -> Rule<T>;
}
```

### Validation Helper

```rust
pub fn validate<T>(
    path: impl Into<Path>,
    value: &T,
    rule: Rule<T>
) -> Result<(), ValidationError>;
```

---

## Derive Macro: `#[derive(Validate)]`

### Supported Attributes

```rust
#[derive(Validate)]
struct BookingRequest {
    // Length constraints
    #[validate(length(min = 3, max = 50, code = "invalid_length"))]
    name: String,
    
    // Range constraints
    #[validate(range(min = 1, max = 10))]
    guests: u8,
    
    // Nested validation
    #[validate(nested)]
    primary_guest: Guest,
    
    // Collection validation (each element)
    #[validate(length(min = 1, message = "At least one room required"))]
    #[validate(each(nested))]
    rooms: Vec<Room>,
    
    // Custom validator function
    #[validate(custom = "validate_dates")]
    dates: DateRange,
    
    // Conditional validation
    #[validate(when = "requires_payment")]
    #[validate(nested)]
    payment: Option<Payment>,
}

fn requires_payment(req: &BookingRequest) -> bool {
    req.guests > 5
}
```

### Generated Code Pattern

```rust
impl Validate for BookingRequest {
    fn validate(&self) -> Result<(), ValidationError> {
        let mut err = ValidationError::default();
        
        // Length check on name
        if self.name.len() < 3 || self.name.len() > 50 {
            err.push("name", "invalid_length", "Must be 3-50 characters");
        }
        
        // Range check on guests
        if !(1..=10).contains(&self.guests) {
            err.push("guests", "out_of_range", "Must be between 1 and 10");
        }
        
        // Nested validation with path prefixing
        if let Err(e) = self.primary_guest.validate() {
            err.merge_prefixed("primary_guest", e);
        }
        
        // Collection validation with indexed paths
        for (i, room) in self.rooms.iter().enumerate() {
            if let Err(e) = room.validate() {
                err.merge_prefixed(format!("rooms[{}]", i), e);
            }
        }
        
        if err.is_empty() { Ok(()) } else { Err(err) }
    }
}
```

---

## Real-World Example: Hotel Booking

### Domain Primitives

```rust
use domain_model::prelude::*;

/// Email with validation
#[derive(Debug, Clone)]
pub struct Email(String);

impl Email {
    pub fn new(raw: impl Into<String>) -> Result<Self, ValidationError> {
        let raw = raw.into();
        validate("email", &raw, rules::email().and(rules::max_len(255)))?;
        Ok(Self(raw))
    }
    
    pub fn as_str(&self) -> &str { &self.0 }
}

/// Check-in date (cannot be in the past)
#[derive(Debug, Clone)]
pub struct CheckInDate(DateTime<Utc>);

impl CheckInDate {
    pub fn new(date: DateTime<Utc>) -> Result<Self, ValidationError> {
        let today = Utc::now().date_naive();
        if date.date_naive() < today {
            return Err(ValidationError::single(
                "check_in",
                "past_date",
                "Check-in cannot be in the past"
            ));
        }
        Ok(Self(date))
    }
}
```

### Domain Aggregate

```rust
#[derive(Debug, Validate)]
pub struct BookingRequest {
    #[validate(length(min = 1, message = "Name required"))]
    pub name: String,
    
    #[validate(nested)]
    pub email: Email,
    
    #[validate(range(min = 1, max = 10))]
    pub guests: u8,
    
    #[validate(nested)]
    pub check_in: CheckInDate,
    
    #[validate(nested)]
    pub check_out: CheckOutDate,
}

impl BookingRequest {
    pub fn new(
        name: String,
        email: Email,
        guests: u8,
        check_in: CheckInDate,
        check_out: CheckOutDate,
    ) -> Result<Self, ValidationError> {
        let req = Self { name, email, guests, check_in, check_out };
        
        // Derive-generated field validation
        req.validate()?;
        
        // Cross-field validation
        if check_out.0 <= check_in.0 {
            return Err(ValidationError::single(
                "check_out",
                "invalid_date_range",
                "Check-out must be after check-in"
            ));
        }
        
        Ok(req)
    }
}
```

### Async Validation (Uniqueness Checks)

```rust
pub trait BookingChecks: Send + Sync {
    async fn email_exists(&self, email: &str) -> Result<bool, anyhow::Error>;
}

impl<C: BookingChecks> AsyncValidate<C> for BookingRequest {
    type Fut<'a> = impl Future<Output = Result<(), ValidationError>> + Send + 'a
    where Self: 'a, C: 'a;
    
    fn validate_async<'a>(&'a self, ctx: &'a C) -> Self::Fut<'a> {
        async move {
            // Sync validation first
            self.validate()?;
            
            // Async check: email uniqueness
            if ctx.email_exists(self.email.as_str()).await? {
                return Err(ValidationError::single(
                    "email",
                    "email_exists",
                    "Email already registered"
                ));
            }
            
            Ok(())
        }
    }
}
```

### HTTP Handler Integration

```rust
use axum::{Json, extract::State};
use error_envelope::Error;

#[derive(Deserialize)]
struct BookingDto {
    name: String,
    email: String,
    guests: u8,
    check_in: String,
    check_out: String,
}

impl TryFrom<BookingDto> for BookingRequest {
    type Error = ValidationError;
    
    fn try_from(dto: BookingDto) -> Result<Self, Self::Error> {
        BookingRequest::new(
            dto.name,
            Email::new(dto.email)?,
            dto.guests,
            CheckInDate::parse(&dto.check_in)?,
            CheckOutDate::parse(&dto.check_out)?,
        )
    }
}

async fn create_booking(
    State(checks): State<Arc<dyn BookingChecks>>,
    ValidatedJson(request): ValidatedJson<BookingRequest>,
) -> Result<Json<BookingConfirmation>, Error> {
    // Sync validation already done by ValidatedJson
    
    // Async validation
    request.validate_async(&*checks)
        .await
        .map_err(|e| Error::validation(e.field_errors_map()))?;
    
    // Domain logic
    let booking = create_booking_internal(request).await?;
    Ok(Json(booking))
}
```

---

## Crate Structure

```
domain-model/
├── domain-model/           # Core crate (no macros)
│   ├── lib.rs
│   ├── path.rs            # Path, PathSegment
│   ├── violation.rs       # Violation, Meta
│   ├── error.rs           # ValidationError
│   ├── rule.rs            # Rule<T> algebra
│   ├── rules/             # Built-in rules
│   │   ├── mod.rs
│   │   ├── string.rs      # email, min_len, max_len
│   │   ├── numeric.rs     # range
│   │   └── optional.rs    # regex, url (feature-gated)
│   └── prelude.rs
│
├── domain-model-derive/    # Proc macros
│   ├── lib.rs
│   └── validate.rs        # #[derive(Validate)]
│
├── domain-model-serde/     # Optional serde integration
│   ├── lib.rs
│   └── validated.rs       # ValidatedJson<T>
│
├── domain-model-error-envelope/  # Optional error_envelope integration
│   └── lib.rs             # impl From<ValidationError> for Error
│
└── examples/
    ├── hotel_booking.rs
    └── user_registration.rs
```

### Feature Flags

```toml
[features]
default = ["std"]
std = []
alloc = []

# Optional rules
regex = ["dep:regex"]
email = ["dep:regex"]
url = ["dep:url"]

# Integration
serde = ["dep:serde", "dep:serde_json"]
axum = ["dep:axum", "serde"]
error_envelope = ["dep:error-envelope"]
```

---

## Development Roadmap

### v0.1 (MVP - 2-3 weeks)
- [ ] Core types: `ValidationError`, `Violation`, `Path`
- [ ] `Rule<T>` with `and`, `or`, `when` combinators
- [ ] Built-in rules: `email`, `min_len`, `max_len`, `range`, `non_empty`
- [ ] `validate()` helper function
- [ ] Manual domain type pattern (no macros yet)
- [ ] Basic tests and examples

**Deliverable:** Can manually build validated domain types with composable rules.

### v0.2 (Derive Macro)
- [ ] `#[derive(Validate)]` for structs
- [ ] Attributes: `length`, `range`, `nested`, `each(nested)`, `custom`
- [ ] Path prefixing for nested structs and collections
- [ ] Good compiler error messages
- [ ] Comprehensive macro tests

**Deliverable:** Ergonomic attribute-based validation with zero boilerplate.

### v0.3 (Serde Integration)
- [ ] `domain-model-serde` crate
- [ ] `ValidatedJson<T>` wrapper for Axum
- [ ] DTO → Domain conversion pattern
- [ ] Example: hotel booking API

**Deliverable:** Drop-in HTTP integration for web services.

### v0.4 (Error Envelope Integration)
- [ ] `domain-model-error-envelope` crate
- [ ] `impl From<ValidationError> for error_envelope::Error`
- [ ] Structured field errors in HTTP responses
- [ ] Example: error envelope with field paths

**Deliverable:** Production-ready API error responses.

### v0.5 (Async Validation)
- [ ] `AsyncValidate<Ctx>` trait (GAT-based)
- [ ] Context pattern for DB/API checks
- [ ] Async rule helpers: `validate_each_concurrent`
- [ ] Path prefixing for async violations
- [ ] Example: uniqueness checks

**Deliverable:** Full async validation support for service backends.

### v0.6+ (Future)
- [ ] Conditional validation (`when` attribute)
- [ ] Schema generation (OpenAPI / JSON Schema)
- [ ] More built-in rules (url, uuid, phone, etc.)
- [ ] Performance benchmarks
- [ ] `no_std` support

---

## Success Metrics

### Adoption Indicators
- Used in 5+ production services
- 100+ GitHub stars
- Mentioned in Rust web framework guides
- Integration examples in Axum/Actix docs

### Technical Goals
- Zero-cost abstractions (no runtime overhead vs manual validation)
- Compile times < 5s for derive macro heavy projects
- Error messages as clear as standard library
- 100% test coverage for core + derive

### Community Validation
- Positive feedback from domain-driven design practitioners
- Comparison blog posts vs `validator`/`garde`
- Requests for specific framework integrations

---

## Comparison with Existing Solutions

### vs validator

| Aspect | validator | domain-model |
|--------|-----------|--------------|
| **Philosophy** | DTO validation | Domain modeling |
| **Error paths** | Basic | Fully structured |
| **Async validation** | No | Yes (context-based) |
| **Rule composition** | Attributes only | First-class values |
| **HTTP integration** | Manual | Built-in (optional) |

### vs garde

| Aspect | garde | domain-model |
|--------|-------|--------------|
| **Philosophy** | DTO validation | Domain modeling |
| **Nested errors** | Yes | Yes (better paths) |
| **Async validation** | No | Yes |
| **Composable rules** | Limited | Full algebra |
| **Domain types** | No focus | Primary focus |

### vs nutype

| Aspect | nutype | domain-model |
|--------|--------|--------------|
| **Philosophy** | Newtype primitives | Full aggregates |
| **Scope** | Single values | Structs + collections |
| **Error reporting** | Per-field | Structured paths |
| **Async validation** | No | Yes |
| **Composition** | Limited | Full support |

### Unique Selling Points

1. **Domain-first design** - DTO → Domain is the primary path
2. **Full error paths** - `rooms[0].adults`, not just field names
3. **Composable rules** - Rules as first-class values
4. **Async + sync** - One coherent framework for both
5. **HTTP ecosystem** - error_envelope, axum, actix integration

---

## Open Questions

### Design Decisions Needed

1. **Error collection strategy:**
   - Collect all errors (current design)
   - Or fail-fast on first error?
   - Make it configurable?

2. **Macro expansion:**
   - Generate `impl Validate` directly
   - Or generate helper functions and call from trait impl?

3. **Async trait design:**
   - Use GAT (current, requires MSRV 1.65+)
   - Or require `Pin<Box<dyn Future>>` for lower MSRV?

4. **Meta field:**
   - Feature-gate `serde_json` for zero-cost opt-out
   - Or always include but keep lightweight?

5. **Path syntax:**
   - Support string parsing: `"rooms[0].adults"`
   - Or require programmatic construction?

### Community Input Needed

- What validation rules are most commonly needed?
- What async validation patterns are common in services?
- What HTTP frameworks should be prioritized?
- Should we support GraphQL / gRPC error mapping?

---

## References

### Inspiration

- **ZIO Schema** (Scala) - Type-safe schema definitions
- **dry-validation** (Ruby) - Declarative validation rules
- **validator** (Rust) - Attribute-based validation
- **garde** (Rust) - Nested validation
- **nutype** (Rust) - Validated newtypes

### Related Crates

- `thiserror` - Custom error types
- `anyhow` - Flexible error handling
- `error-envelope` - HTTP error responses
- `serde` - Serialization/deserialization
- `axum` - Web framework
- `validator` - DTO validation
- `garde` - Nested validation
- `nutype` - Validated primitives

---

## License

MIT (tentative)

---

## Contact

**Maintainer:** TBD  
**Repository:** (not yet created)  
**Discussions:** (not yet created)

---

**Last Updated:** 2025-12-23
