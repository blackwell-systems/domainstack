# domain-model v0.3 Implementation Plan

**Status:** Planning  
**Theme:** "One integration, done right"  
**Target:** 2–3 weeks after v0.2 stabilization  
**Focus:** error-envelope integration (framework-agnostic)

---

## v0.3 Scope

### Goal
Make validation errors plug into existing service error handling with **one-line conversion** and **consistent API error shape**, without turning `domain-model` into a web framework.

### In Scope
- New crate: `domain-model-error-envelope`
- `From<ValidationError> for error_envelope::Error` (or equivalent trait)
- Structured field error mapping that preserves:
  - `path` (e.g., `rooms[0].adults`)
  - `code` (stable, machine-readable)
  - `message` (human-readable)
  - `meta` (min/max/etc, feature-gated if needed)
- Examples:
  - Minimal HTTP handler example (pseudo or axum snippet)
  - Error JSON shape example
- Tests ensuring:
  - stable top-level error code + HTTP status
  - correct mapping of fields and violations
  - meta propagation (if enabled)

### Out of Scope
- Axum extractors (`ValidatedJson<T>`)  
- Serde validate-on-deserialize  
- Async validation  
- Schema generation  
- Additional core rules beyond v0.2

---

## Crate Structure

```text
domain-model/
├── domain-model/                      # core
├── domain-model-derive/               # proc-macro (v0.2)
├── domain-model-error-envelope/       # v0.3 integration
└── examples/
    ├── v3_error_envelope_basic.rs
    └── v3_error_envelope_nested.rs
```

### Workspace Cargo.toml
```toml
[workspace]
members = ["domain-model", "domain-model-derive", "domain-model-error-envelope"]
resolver = "2"
```

### domain-model-error-envelope/Cargo.toml
```toml
[package]
name = "domain-model-error-envelope"
version = "0.3.0"
edition = "2021"
rust-version = "1.65"
license = "MIT"

[dependencies]
domain-model = { version = "0.3.0", path = "../domain-model" }
error-envelope = "X.Y"  # pin to known-good
serde_json = { version = "1", optional = true }

[features]
default = []
json = ["dep:serde_json"]   # only if you want to embed meta as JSON
```

---

## Error Mapping Design

### Top-Level Error Policy

All validation errors map to:
- **HTTP status:** 400
- **envelope code:** `Code::InvalidArgument` (or your chosen equivalent)
- **retryable:** false

### Details Shape (recommended)

Use `details["fields"]` as a map of field-path → array of violation objects:

```json
{
  "code": "INVALID_ARGUMENT",
  "message": "Validation failed with 2 errors",
  "status": 400,
  "retryable": false,
  "details": {
    "fields": {
      "guest.email": [
        {"code": "invalid_email", "message": "Invalid email format", "meta": {"max": 255}}
      ],
      "rooms[0].adults": [
        {"code": "out_of_range", "message": "Must be between 1 and 4", "meta": {"min": 1, "max": 4}}
      ]
    }
  }
}
```

**Notes:**
- Clients can render field errors directly.
- Stable `code` supports programmatic handling.
- `meta` is optional; include only when available.

---

## Public API

### Option A (preferred): From impl
```rust
impl From<domain_model::ValidationError> for error_envelope::Error
```

### Option B: explicit helper trait
```rust
pub trait IntoApiError {
    fn into_api_error(self) -> error_envelope::Error;
}

impl IntoApiError for domain_model::ValidationError { ... }
```

**Recommendation:** Option A so user code is one-liner and idiomatic.

---

## Core Enhancements Needed (small)

Add this to `domain-model` core if not already present:

```rust
impl ValidationError {
    /// Group violations by path string for API presentation.
    pub fn field_violations_map(&self) -> std::collections::BTreeMap<String, Vec<&Violation>>;
}
```

Or, keep it owned if you prefer:
```rust
pub fn field_errors_map(&self) -> BTreeMap<String, Vec<Violation>>;
```

---

## Implementation Tasks

### Phase 1: Integration Crate Skeleton (Day 1)
- Create `domain-model-error-envelope` crate
- Wire workspace members
- Add minimal example compile check

### Phase 2: Define Mapping Functions (Days 2–3)
- Decide final `details["fields"]` shape
- Implement conversion:
  - top-level status/code/retryable
  - details from violations
- Ensure nested/collection paths are preserved

### Phase 3: Meta Handling (Day 4)
- If `Meta` is not JSON, decide representation:
  - omit `meta` entirely (simplest), OR
  - include as string map (`BTreeMap<&str, String>`), OR
  - feature-gate JSON conversion via `serde_json`
- **Recommendation:** ship without JSON meta in v0.3 unless you already have it.

### Phase 4: Tests (Days 5–7)
- Unit tests for conversion:
  - single violation
  - multiple violations same path
  - nested path
  - collection path
- Snapshot-like assertions on `details.fields` keys
- Verify status/code/retryable constants

### Phase 5: Examples + Docs (Days 8–10)
- Example: mapping errors in a handler
- Example: nested + each paths
- README section: "Integrations: error-envelope"

---

## Success Criteria

- ✅ One-line conversion: `map_err(error_envelope::Error::from)?`
- ✅ Stable error format across endpoints
- ✅ Field paths preserved exactly (`a.b[0].c`)
- ✅ Works without axum/serde dependencies
- ✅ Tests cover mapping semantics
