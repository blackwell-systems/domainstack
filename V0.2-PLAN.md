# domain-model v0.2 Implementation Plan

**Status:** Planning  
**Theme:** "Ergonomics without magic"  
**Target:** 3-4 weeks after v0.1 feedback  
**Focus:** Derive macro + collection validation + better diagnostics

---

## Overview

v0.2 adds `#[derive(Validate)]` to eliminate boilerplate while maintaining the explicit, composable design from v0.1. The goal is to make users say: "This is nicer than hand-writing Validate impls."

### What Changes

**Before (v0.1):**
```rust
impl Validate for BookingRequest {
    fn validate(&self) -> Result<(), ValidationError> {
        let mut err = ValidationError::default();
        
        if let Err(e) = validate("name", self.name.as_str(), rules::min_len(1)) {
            err.extend(e);
        }
        
        if let Err(e) = self.guest.validate() {
            err.merge_prefixed("guest", e);
        }
        
        if err.is_empty() { Ok(()) } else { Err(err) }
    }
}
```

**After (v0.2):**
```rust
#[derive(Validate)]
struct BookingRequest {
    #[validate(length(min = 1))]
    name: String,
    
    #[validate(nested)]
    guest: Guest,
    
    #[validate(range(min = 1, max = 10))]
    guests: u8,
}
```

---

## Crate Structure

```text
domain-model/
├── domain-model/              # Core validation (v0.1 code + helpers)
├── domain-model-derive/       # Proc macro crate
└── examples/
    ├── v1_manual.rs          # Show v0.1 manual impl
    ├── v2_derived.rs         # Show v0.2 derive
    └── v2_collections.rs     # Vec/collection validation
```

### Workspace Cargo.toml

```toml
[workspace]
members = ["domain-model", "domain-model-derive"]
resolver = "2"

[workspace.dependencies]
domain-model = { version = "0.2", path = "domain-model" }
```

### domain-model-derive/Cargo.toml

```toml
[package]
name = "domain-model-derive"
version = "0.2.0"
edition = "2021"
rust-version = "1.65"

[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0", features = ["full", "extra-traits"] }
quote = "1.0"
proc-macro2 = "1.0"

[dev-dependencies]
trybuild = "1.0"
```

---

## Supported Attributes (v0.2)

### 1. String Length Validation

```rust
#[validate(length(min = 3, max = 50))]
name: String

#[validate(length(min = 3, max = 50, code = "invalid_name", message = "Name must be 3-50 chars"))]
name: String
```

**Allowed on:** `String`, `&str`, `Cow<'_, str>`

**Defaults:**
- `code`: `"invalid_length"`
- `message`: Auto-generated from min/max

**Generated code:**
```rust
if let Err(e) = validate("name", self.name.as_str(), 
    rules::min_len(3).and(rules::max_len(50))) {
    err.extend(e);
}
```

### 2. Numeric Range Validation

```rust
#[validate(range(min = 1, max = 10))]
guests: u8

#[validate(range(min = 18, max = 120, code = "invalid_age"))]
age: u8
```

**Allowed on:** Types implementing `PartialOrd + Copy + Display`

**Defaults:**
- `code`: `"out_of_range"`
- `message`: Auto-generated

**Generated code:**
```rust
if let Err(e) = validate("guests", &self.guests, rules::range(1, 10)) {
    err.extend(e);
}
```

### 3. Nested Validation

```rust
#[validate(nested)]
guest: Guest

#[validate(nested)]
guest: Option<Guest>

#[validate(nested)]
guest: Box<Guest>
```

**Allowed on:** `T: Validate`, `Option<T>`, `Box<T>`

**Generated code:**
```rust
// T: Validate
if let Err(e) = self.guest.validate() {
    err.merge_prefixed("guest", e);
}

// Option<T>
if let Some(ref guest) = self.guest {
    if let Err(e) = guest.validate() {
        err.merge_prefixed("guest", e);
    }
}

// Box<T>
if let Err(e) = self.guest.validate() {
    err.merge_prefixed("guest", e);
}
```

### 4. Collection (Each) Validation

```rust
#[validate(each(nested))]
rooms: Vec<Room>

#[validate(each(range(min = 1, max = 4)))]
guest_counts: Vec<u8>

#[validate(each(length(min = 1, max = 50)))]
names: Vec<String>
```

**Allowed on:** `Vec<T>` (v0.2 only; slices/HashSet in v0.3)

**Generated code:**
```rust
// each(nested)
for (i, room) in self.rooms.iter().enumerate() {
    if let Err(e) = room.validate() {
        err.merge_prefixed(format!("rooms[{}]", i), e);
    }
}

// each(range)
for (i, count) in self.guest_counts.iter().enumerate() {
    if let Err(e) = validate(
        format!("guest_counts[{}]", i),
        count,
        rules::range(1, 4)
    ) {
        err.extend(e);
    }
}
```

### 5. Custom Validation

```rust
#[validate(custom = "validate_dates")]
date_range: DateRange

#[validate(custom = "my_module::check_email")]
email: String
```

**Function signature (enforced):**
```rust
fn validate_dates(value: &DateRange) -> Result<(), ValidationError>
```

**Generated code:**
```rust
if let Err(mut e) = validate_dates(&self.date_range) {
    // Prefix all violations with field name if they're root-level
    for violation in &mut e.violations {
        if violation.path.0.is_empty() {
            violation.path = Path::from("date_range");
        } else {
            // If custom fn already set path, prepend field name
            let mut segments = vec![PathSegment::Field("date_range")];
            segments.extend(violation.path.0.clone());
            violation.path = Path(segments);
        }
    }
    err.extend(e);
}
```

---

## Attribute Composition Rules

### Allowed Combinations

```rust
// Multiple constraints on one field
#[validate(length(min = 1, max = 50))]
#[validate(custom = "check_profanity")]
name: String

// Nested + other validations not allowed
#[validate(nested)]        // OK
email: Email

#[validate(nested)]        // ERROR: nested cannot combine with other rules
#[validate(custom = "foo")]
email: Email
```

### Combination Matrix

| Attribute | length | range | nested | each | custom |
|-----------|--------|-------|--------|------|--------|
| length    | ❌     | ❌    | ❌     | ❌   | ✅     |
| range     | ❌     | ❌    | ❌     | ❌   | ✅     |
| nested    | ❌     | ❌    | ❌     | ❌   | ❌     |
| each      | ❌     | ❌    | ❌     | ❌   | ❌     |
| custom    | ✅     | ✅    | ❌     | ❌   | ✅     |

---

## Diagnostics (Compile Errors)

v0.2 must provide clear, actionable compile errors for common mistakes.

### Type Mismatches

```rust
#[derive(Validate)]
struct Bad {
    #[validate(range(min = 1, max = 10))]
    name: String,  // ERROR
}
```

**Error message:**
```text
error: #[validate(range)] requires a numeric type implementing PartialOrd + Copy + Display
  --> src/main.rs:4:5
   |
4  |     #[validate(range(min = 1, max = 10))]
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: found type: String
   = help: use #[validate(length(...))] for string types
```

### Collection Type Mismatches

```rust
#[derive(Validate)]
struct Bad {
    #[validate(each(nested))]
    guest: Guest,  // ERROR: not a collection
}
```

**Error message:**
```text
error: #[validate(each(...))] requires a collection type (Vec<T>)
  --> src/main.rs:4:5
   |
4  |     #[validate(each(nested))]
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: found type: Guest
   = help: use #[validate(nested)] for non-collection types
```

### Missing Trait Bounds

```rust
#[derive(Validate)]
struct Bad {
    #[validate(nested)]
    guest: Guest,  // ERROR: Guest doesn't implement Validate
}
```

**Error message:**
```text
error: #[validate(nested)] requires type to implement Validate trait
  --> src/main.rs:4:5
   |
4  |     #[validate(nested)]
   |     ^^^^^^^^^^^^^^^^^^^^
   |
   = note: type Guest does not implement domain_model::Validate
   = help: add #[derive(Validate)] to Guest or implement Validate manually
```

### Attribute Conflicts

```rust
#[derive(Validate)]
struct Bad {
    #[validate(nested)]
    #[validate(length(min = 1))]
    guest: Guest,  // ERROR: nested cannot combine with other rules
}
```

**Error message:**
```text
error: #[validate(nested)] cannot be combined with other validation attributes
  --> src/main.rs:5:5
   |
5  |     #[validate(length(min = 1))]
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: nested validation validates the entire type, not individual fields
   = help: remove conflicting attributes or use a custom validation function
```

---

## Core Library Enhancements (domain-model)

### New Helpers in ValidationError

```rust
impl ValidationError {
    /// Merge multiple errors at once
    pub fn merge<I>(&mut self, errors: I)
    where
        I: IntoIterator<Item = ValidationError>,
    {
        for error in errors {
            self.extend(error);
        }
    }
    
    /// Merge multiple prefixed errors
    pub fn merge_prefixed_many<I, P>(&mut self, items: I)
    where
        I: IntoIterator<Item = (P, ValidationError)>,
        P: Into<Path>,
    {
        for (prefix, error) in items {
            self.merge_prefixed(prefix, error);
        }
    }
}
```

### Path Builder Methods (Already in v0.1)

These are already implemented, but we'll document them better:

```rust
impl Path {
    pub fn root() -> Self;
    pub fn field(self, name: &'static str) -> Self;
    pub fn index(self, idx: usize) -> Self;
}
```

---

## Implementation Tasks

### Phase 1: Project Setup (Week 1, Days 1-2)

#### Task 1.1: Create Workspace
- Convert to workspace layout
- Add domain-model-derive crate
- Update Cargo.toml files
- Ensure v0.1 still builds

#### Task 1.2: Add Dev Dependencies
- Add `trybuild` for compile-fail tests
- Add `syn`, `quote`, `proc-macro2`
- Set up test infrastructure

### Phase 2: Basic Derive Macro (Week 1, Days 3-5)

#### Task 2.1: Parse Struct Definition
- Parse struct with named fields
- Extract field names and types
- Handle visibility, generics (basic)

#### Task 2.2: Parse #[validate(...)] Attributes
- Parse `length(min=N, max=M)`
- Parse `range(min=N, max=M)`
- Parse `nested`
- Store in intermediate representation

#### Task 2.3: Generate Validate Impl (No Attributes)
- Generate basic `impl Validate` skeleton
- Test with struct with no validations
- Ensure it compiles

### Phase 3: Attribute Implementation (Week 2)

#### Task 3.1: Implement `length` Attribute
- Generate code for `String`, `&str`
- Handle min-only, max-only, both
- Custom code/message support
- Tests

#### Task 3.2: Implement `range` Attribute
- Generate code for numeric types
- Type checking (must be PartialOrd)
- Tests for u8, i32, f64

#### Task 3.3: Implement `nested` Attribute
- Basic nested validation
- Handle Option<T>
- Handle Box<T>
- Proper path prefixing

### Phase 4: Collection Validation (Week 3, Days 1-3)

#### Task 4.1: Implement `each(nested)`
- Parse `each(...)` syntax
- Generate indexed iteration
- Path with array indices: `rooms[0].name`

#### Task 4.2: Implement `each(range)` and `each(length)`
- Support primitive validation in collections
- Test with Vec<u8>, Vec<String>

### Phase 5: Custom Validation (Week 3, Days 4-5)

#### Task 5.1: Implement `custom` Attribute
- Parse function path
- Generate function call
- Handle path prefixing
- Validation function signature checking

### Phase 6: Diagnostics (Week 4, Days 1-2)

#### Task 6.1: Type Checking
- Detect range on non-numeric
- Detect length on non-string
- Detect each on non-collection
- Emit compile_error! macros

#### Task 6.2: Trait Bound Checking
- Check nested requires Validate
- Generate helpful error messages

### Phase 7: Testing (Week 4, Days 3-5)

#### Task 7.1: Trybuild Tests
- Compile-fail tests for all error cases
- Golden file tests for expansion

#### Task 7.2: Integration Tests
- Test all attribute types
- Test combinations
- Test path correctness
- Test error accumulation

#### Task 7.3: Examples
- Convert v0.1 examples to use derive
- Add collection validation example
- Add custom validation example

---

## Testing Strategy

### Compile-Fail Tests (trybuild)

```rust
// tests/ui/range_on_string.rs
use domain_model::Validate;

#[derive(Validate)]
struct Bad {
    #[validate(range(min = 1, max = 10))]
    name: String,
}

fn main() {}
```

```text
// tests/ui/range_on_string.stderr
error: #[validate(range)] requires a numeric type
  --> tests/ui/range_on_string.rs:5:5
   |
5  |     #[validate(range(min = 1, max = 10))]
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```

### Expansion Tests

```rust
#[test]
fn test_basic_derive() {
    let t = trybuild::TestCases::new();
    t.pass("tests/expand/basic.rs");
    t.compile_fail("tests/ui/*.rs");
}
```

### Integration Tests

```rust
#[test]
fn test_nested_validation_paths() {
    #[derive(Validate)]
    struct Inner {
        #[validate(length(min = 1))]
        name: String,
    }
    
    #[derive(Validate)]
    struct Outer {
        #[validate(nested)]
        inner: Inner,
    }
    
    let outer = Outer {
        inner: Inner { name: "".to_string() }
    };
    
    let err = outer.validate().unwrap_err();
    assert_eq!(err.violations.len(), 1);
    assert_eq!(err.violations[0].path.to_string(), "inner.name");
}
```

---

## Examples

### Example 1: Basic Derive (v2_basic.rs)

```rust
use domain_model::prelude::*;

#[derive(Debug, Validate)]
struct User {
    #[validate(length(min = 1, max = 50))]
    name: String,
    
    #[validate(range(min = 18, max = 120))]
    age: u8,
}

fn main() {
    let user = User {
        name: "".to_string(),
        age: 15,
    };
    
    match user.validate() {
        Ok(()) => println!("Valid user"),
        Err(e) => {
            println!("Validation failed:");
            for v in &e.violations {
                println!("  [{} {}] {}", v.path, v.code, v.message);
            }
        }
    }
}
```

### Example 2: Nested Validation (v2_nested.rs)

```rust
use domain_model::prelude::*;

#[derive(Debug, Validate)]
struct Email(String);

impl Email {
    pub fn new(s: String) -> Result<Self, ValidationError> {
        validate("email", s.as_str(), rules::email())?;
        Ok(Self(s))
    }
}

#[derive(Debug, Validate)]
struct Guest {
    #[validate(length(min = 1, max = 50))]
    name: String,
    
    #[validate(nested)]
    email: Email,
}

#[derive(Debug, Validate)]
struct Booking {
    #[validate(nested)]
    guest: Guest,
    
    #[validate(range(min = 1, max = 10))]
    guests_count: u8,
}

fn main() {
    let booking = Booking {
        guest: Guest {
            name: "".to_string(),
            email: Email("bad-email".to_string()),
        },
        guests_count: 15,
    };
    
    match booking.validate() {
        Ok(()) => println!("Valid booking"),
        Err(e) => {
            println!("Validation errors:");
            let field_map = e.field_errors_map();
            for (field, messages) in field_map {
                println!("  {}: {:?}", field, messages);
            }
        }
    }
}
```

### Example 3: Collections (v2_collections.rs)

```rust
use domain_model::prelude::*;

#[derive(Debug, Validate)]
struct Room {
    #[validate(range(min = 1, max = 4))]
    adults: u8,
    
    #[validate(range(min = 0, max = 3))]
    children: u8,
}

#[derive(Debug, Validate)]
struct HotelBooking {
    #[validate(length(min = 1))]
    guest_name: String,
    
    #[validate(each(nested))]
    rooms: Vec<Room>,
}

fn main() {
    let booking = HotelBooking {
        guest_name: "John Doe".to_string(),
        rooms: vec![
            Room { adults: 2, children: 1 },
            Room { adults: 5, children: 0 },  // Invalid: too many adults
            Room { adults: 1, children: 4 },  // Invalid: too many children
        ],
    };
    
    match booking.validate() {
        Ok(()) => println!("Valid booking"),
        Err(e) => {
            println!("Found {} errors:", e.violations.len());
            for v in &e.violations {
                println!("  [{}] {}: {}", v.path, v.code, v.message);
            }
        }
    }
}
```

### Example 4: Custom Validation (v2_custom.rs)

```rust
use domain_model::prelude::*;

#[derive(Debug)]
struct DateRange {
    start: String,
    end: String,
}

fn validate_date_range(range: &DateRange) -> Result<(), ValidationError> {
    // Custom logic: ensure end > start
    if range.end <= range.start {
        return Err(ValidationError::single(
            Path::root(),
            "invalid_date_range",
            "End date must be after start date"
        ));
    }
    Ok(())
}

#[derive(Debug, Validate)]
struct Booking {
    #[validate(length(min = 1))]
    guest: String,
    
    #[validate(custom = "validate_date_range")]
    dates: DateRange,
}

fn main() {
    let booking = Booking {
        guest: "John".to_string(),
        dates: DateRange {
            start: "2025-01-15".to_string(),
            end: "2025-01-10".to_string(),
        },
    };
    
    match booking.validate() {
        Ok(()) => println!("Valid"),
        Err(e) => {
            for v in &e.violations {
                println!("[{}] {}", v.path, v.message);
            }
        }
    }
}
```

---

## Success Criteria

### Functional Requirements

- ✅ Basic derive works for structs with named fields
- ✅ `length`, `range`, `nested`, `each`, `custom` all implemented
- ✅ Path prefixing correct for nested and collections
- ✅ Multiple violations accumulate properly
- ✅ Option<T> and Box<T> handled correctly
- ✅ Clear compile errors for misuse

### Non-Functional Requirements

- ✅ Compile time < 10s for moderate codebases
- ✅ Generated code is readable (cargo expand)
- ✅ Error messages are actionable
- ✅ 95%+ test coverage for macro
- ✅ Documentation for all attributes

### API Stability

- ✅ No breaking changes to v0.1 API
- ✅ Derive is optional (can still write manual impls)
- ✅ Generated code uses stable v0.1 APIs

---

## Non-Goals (v0.2)

What we're **explicitly not doing** in v0.2:

❌ Serde integration  
❌ Axum extractors  
❌ error-envelope mapping  
❌ Async validation  
❌ Enum support  
❌ HashSet/HashMap validation  
❌ Tuple structs  
❌ Generics support (beyond basic)  
❌ Conditional validation (when)  
❌ Cross-field validation helpers  

These are v0.3+ features.

---

## Risks & Mitigation

### Risk 1: Proc Macro Complexity

**Risk:** Proc macros are hard to debug and test.

**Mitigation:**
- Start with simplest possible macro
- Add features incrementally
- Use trybuild for compile-fail tests
- Test expansion with cargo-expand

### Risk 2: Error Message Quality

**Risk:** Cryptic errors frustrate users.

**Mitigation:**
- Write compile-fail tests first
- Use `compile_error!` for known issues
- Test error messages with real users
- Iterate based on feedback

### Risk 3: Type System Limitations

**Risk:** Can't perfectly type-check in macro.

**Mitigation:**
- Do basic checks (Vec vs non-Vec)
- Let rustc handle complex cases
- Provide good error messages when rustc fails

---

## Timeline

### Week 1
- **Days 1-2:** Project setup, workspace conversion
- **Days 3-5:** Basic derive macro (no attributes)

### Week 2
- **Days 1-2:** `length` attribute
- **Days 3-4:** `range` attribute  
- **Day 5:** `nested` attribute (basic)

### Week 3
- **Days 1-3:** Collection validation (`each`)
- **Days 4-5:** Custom validation

### Week 4
- **Days 1-2:** Diagnostics and error messages
- **Days 3-5:** Testing, examples, documentation

### Week 5 (Buffer)
- Polish based on self-testing
- Documentation improvements
- Prepare for feedback

---

## Post-v0.2 Roadmap

### v0.3: Service Integration

Pick **one** integration to nail:

**Option A: Axum Integration**
- `ValidatedJson<T>` extractor
- Automatic 400 responses with field errors
- Integration with tower middleware

**Option B: error-envelope Integration**
- `.into_api_error()` on ValidationError
- Field-level error mapping
- HTTP status code selection

**Other v0.3 features:**
- HashSet/HashMap validation
- Tuple struct support
- Basic enum support (field-level only)

### v0.4: Advanced Features

- Async validation
- Cross-field validation helpers
- Conditional validation (when)
- Full generic support

---

## Open Questions (Decide Before Implementation)

### Question 1: Dynamic Path Allocation

**Issue:** `format!("rooms[{}]", i)` allocates.

**Options:**
a) Accept allocation (simplest)
b) Add `Path::push_segment_owned(String)` method
c) Use a small-string optimization

**Decision needed by:** Week 3, Day 1

**Recommendation:** Option (a) for v0.2, optimize in v0.3 if needed

### Question 2: Custom Function Signature

**Issue:** Should custom functions return paths or not?

**Options:**
a) Always return root-level errors, macro prefixes
b) Allow custom functions to set their own paths
c) Support both via two different attributes

**Decision needed by:** Week 3, Day 4

**Recommendation:** Option (b) - macro detects and handles both cases

### Question 3: Generics Support

**Issue:** How much generic support in v0.2?

**Options:**
a) No generics at all
b) Simple generics (no trait bounds checking)
c) Full generic support

**Decision needed by:** Week 1, Day 3

**Recommendation:** Option (b) - generate impl with same bounds as struct

---

## Dependencies

```toml
# domain-model/Cargo.toml (unchanged except version)
[package]
version = "0.2.0"

[dependencies]
regex = { version = "1.10", optional = true }
domain-model-derive = { version = "0.2.0", path = "../domain-model-derive", optional = true }

[features]
default = ["std"]
std = []
email = ["regex"]
derive = ["domain-model-derive"]

# domain-model-derive/Cargo.toml
[dependencies]
syn = { version = "2.0", features = ["full", "extra-traits"] }
quote = "1.0"
proc-macro2 = "1.0"

[dev-dependencies]
trybuild = "1.0"
domain-model = { path = "../domain-model" }
```

---

## Deliverables

### Code
- [ ] domain-model-derive crate with all attributes
- [ ] 4 new examples (basic, nested, collections, custom)
- [ ] 50+ compile-fail tests
- [ ] 100+ integration tests

### Documentation
- [ ] Attribute reference guide
- [ ] Migration guide (v0.1 → v0.2)
- [ ] Generated code examples
- [ ] Troubleshooting guide

### Testing
- [ ] All trybuild tests passing
- [ ] 95%+ macro coverage
- [ ] All examples working
- [ ] No clippy warnings

---

**Last Updated:** 2025-12-23 (v0.1 complete, v0.2 planning phase)
