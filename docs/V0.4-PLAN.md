# v0.4.0 Plan: Axum + Actix Adapters

**Goal:** Make boundary code go from 20 lines to 1 line with framework-specific extractors.

**Philosophy:** Adapters are thin, share logic via `domainstack-http`, and keep the domain-first approach.

---

## Architecture: Layered Adapters

```
┌─────────────────────────────────────────────────┐
│  domainstack-axum / domainstack-actix          │  ← Framework-specific
│  (DomainJson<T> extractor + response)          │     (thin adapters)
└─────────────────────────────────────────────────┘
                     │
┌─────────────────────────────────────────────────┐
│  domainstack-http                               │  ← Shared logic
│  (into_domain, validate_dto helpers)            │     (no framework deps)
└─────────────────────────────────────────────────┘
                     │
┌─────────────────────────────────────────────────┐
│  domainstack-envelope                           │  ← Error mapping
│  (ValidationError → error-envelope::Error)      │     (framework-agnostic)
└─────────────────────────────────────────────────┘
                     │
┌─────────────────────────────────────────────────┐
│  domainstack + domainstack-derive               │  ← Core validation
│  (Validate trait, rules, derive macro)          │     (std-only)
└─────────────────────────────────────────────────┘
```

---

## Workspace Structure

```
domainstack/
  domainstack/                 # core (exists)
  domainstack-derive/          # proc macro (exists)
  domainstack-envelope/        # error-envelope integration (exists)
  domainstack-http/            # NEW: shared HTTP glue (framework-agnostic)
  domainstack-axum/            # NEW: axum extractor + IntoResponse
  domainstack-actix/           # NEW: actix extractor + ResponseError
  examples/
    axum-booking/              # NEW: full axum example
    actix-booking/             # NEW: full actix example
```

---

## Crate 1: `domainstack-http` (Shared Logic)

### Purpose
Framework-agnostic helpers for DTO→Domain conversion and error mapping.

### Dependencies
```toml
[dependencies]
domainstack = { workspace = true }
domainstack-envelope = { workspace = true }
error-envelope = { workspace = true }
```

**No serde, no axum, no actix** - pure domain boundary logic.

### API

```rust
/// Convert DTO to Domain via TryFrom
pub fn into_domain<T, Dto>(dto: Dto) -> Result<T, error_envelope::Error>
where
    T: TryFrom<Dto, Error = domainstack::ValidationError>,
{
    T::try_from(dto).map_err(|e| e.into_envelope_error())
}

/// Validate DTO (optional pattern)
pub fn validate_dto<Dto>(dto: Dto) -> Result<Dto, error_envelope::Error>
where
    Dto: domainstack::Validate,
{
    dto.validate()
        .map(|_| dto)
        .map_err(|e| e.into_envelope_error())
}
```

### Tests
- Unit tests for both helpers
- Mock domain types with intentional validation failures
- Verify error mapping produces correct error-envelope structure

---

## Crate 2: `domainstack-axum`

### Purpose
Axum-specific extractors and response implementations.

### Dependencies
```toml
[dependencies]
domainstack-http = { workspace = true }
error-envelope = { workspace = true }
axum = "0.7"
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1", features = ["macros"] }

[dev-dependencies]
domainstack = { workspace = true, features = ["derive"] }
axum-test = "16"
serde_json = "1"
```

### Public API

```rust
/// Extract and convert DTO → Domain (RECOMMENDED)
pub struct DomainJson<T>(pub T);

/// Extract and validate DTO only (optional)
pub struct ValidatedJson<T>(pub T);
```

### Implementation: `DomainJson<T>`

```rust
use axum::{
    extract::{FromRequest, Request},
    response::{IntoResponse, Response},
    Json,
};

pub struct DomainJson<T>(pub T);

#[axum::async_trait]
impl<T, Dto, S> FromRequest<S> for DomainJson<T>
where
    Dto: serde::de::DeserializeOwned,
    T: TryFrom<Dto, Error = domainstack::ValidationError>,
    S: Send + Sync,
{
    type Rejection = error_envelope::Error;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        // Extract JSON DTO
        let Json(dto) = Json::<Dto>::from_request(req, state)
            .await
            .map_err(map_json_rejection)?;
        
        // Convert to domain
        let domain = domainstack_http::into_domain(dto)?;
        
        Ok(DomainJson(domain))
    }
}

fn map_json_rejection(rejection: axum::extract::rejection::JsonRejection) -> error_envelope::Error {
    error_envelope::Error::invalid_argument(rejection.to_string())
}
```

### Implementation: Response Mapping

```rust
impl axum::response::IntoResponse for error_envelope::Error {
    fn into_response(self) -> Response {
        let status = axum::http::StatusCode::from_u16(self.status)
            .unwrap_or(axum::http::StatusCode::INTERNAL_SERVER_ERROR);
        
        let body = serde_json::to_string(&self)
            .unwrap_or_else(|_| r#"{"code":"INTERNAL","message":"Serialization failed"}"#.to_string());
        
        (status, body).into_response()
    }
}
```

### Tests

```rust
#[tokio::test]
async fn test_domain_json_valid() {
    let app = Router::new()
        .route("/", post(handler));
    
    let response = app
        .oneshot(Request::post("/")
            .header("content-type", "application/json")
            .body(r#"{"name":"Alice","age":30}"#)
            .unwrap())
        .await
        .unwrap();
    
    assert_eq!(response.status(), 200);
}

#[tokio::test]
async fn test_domain_json_invalid() {
    let app = Router::new()
        .route("/", post(handler));
    
    let response = app
        .oneshot(Request::post("/")
            .header("content-type", "application/json")
            .body(r#"{"name":"","age":200}"#)
            .unwrap())
        .await
        .unwrap();
    
    assert_eq!(response.status(), 400);
    
    let body: error_envelope::Error = serde_json::from_slice(&body_bytes).unwrap();
    assert_eq!(body.code, "VALIDATION");
    assert!(body.details.is_some());
}

async fn handler(DomainJson(user): DomainJson<User>) -> Json<User> {
    Json(user)
}
```

---

## Crate 3: `domainstack-actix`

### Purpose
Actix-web-specific extractors and response implementations.

### Dependencies
```toml
[dependencies]
domainstack-http = { workspace = true }
error-envelope = { workspace = true }
actix-web = "4"
serde = { version = "1.0", features = ["derive"] }
futures = "0.3"

[dev-dependencies]
domainstack = { workspace = true, features = ["derive"] }
actix-rt = "2"
serde_json = "1"
```

### Public API

```rust
pub struct DomainJson<T>(pub T);
pub struct ValidatedJson<T>(pub T);
```

### Implementation: `DomainJson<T>`

```rust
use actix_web::{FromRequest, HttpRequest, web};
use futures::future::{ready, Ready};

pub struct DomainJson<T>(pub T);

impl<T, Dto> FromRequest for DomainJson<T>
where
    Dto: serde::de::DeserializeOwned,
    T: TryFrom<Dto, Error = domainstack::ValidationError>,
{
    type Error = error_envelope::Error;
    type Future = Ready<Result<Self, Self::Error>>;

    fn from_request(req: &HttpRequest, payload: &mut actix_web::dev::Payload) -> Self::Future {
        let json_result = web::Json::<Dto>::from_request(req, payload);
        
        ready(match json_result.into_inner() {
            Ok(Json(dto)) => {
                domainstack_http::into_domain(dto)
                    .map(DomainJson)
            }
            Err(e) => Err(map_json_error(e)),
        })
    }
}

fn map_json_error(error: actix_web::error::JsonPayloadError) -> error_envelope::Error {
    error_envelope::Error::invalid_argument(error.to_string())
}
```

### Implementation: Response Mapping

```rust
impl actix_web::ResponseError for error_envelope::Error {
    fn status_code(&self) -> actix_web::http::StatusCode {
        actix_web::http::StatusCode::from_u16(self.status)
            .unwrap_or(actix_web::http::StatusCode::INTERNAL_SERVER_ERROR)
    }

    fn error_response(&self) -> actix_web::HttpResponse {
        actix_web::HttpResponse::build(self.status_code())
            .json(self)
    }
}
```

### Tests

```rust
#[actix_rt::test]
async fn test_domain_json_valid() {
    let app = test::init_service(
        App::new().route("/", web::post().to(handler))
    ).await;
    
    let req = test::TestRequest::post()
        .uri("/")
        .set_json(&json!({"name": "Alice", "age": 30}))
        .to_request();
    
    let resp = test::call_service(&app, req).await;
    assert_eq!(resp.status(), 200);
}

async fn handler(DomainJson(user): DomainJson<User>) -> web::Json<User> {
    web::Json(user)
}
```

---

## Consistent API Across Frameworks

Both `domainstack-axum` and `domainstack-actix` expose:

### Primary Pattern (Recommended)
```rust
DomainJson<T>
```
- Deserializes DTO
- Converts to domain via `TryFrom`
- Returns `error_envelope::Error` on failure
- Handler receives validated domain object

### Secondary Pattern (Optional)
```rust
ValidatedJson<Dto>
```
- Deserializes DTO
- Validates DTO in place
- Returns `error_envelope::Error` on failure
- Handler receives validated DTO

**Same names, same behavior, different framework implementations.**

---

## Version Scope

### v0.4.0 (Initial Release)

**Core deliverables:**
- `domainstack-http` crate
- `domainstack-axum` with `DomainJson<T>` extractor
- `domainstack-actix` with `DomainJson<T>` extractor
- `impl IntoResponse` for Axum
- `impl ResponseError` for Actix
- One example per framework (booking service)
- Integration tests for both

**Documentation:**
- README for each new crate
- Update root README with framework adapter section
- Examples showing the pattern

### v0.4.1+ (Future Enhancements)

- `ValidatedJson<Dto>` extractors
- Query param extractors: `DomainQuery<T, Dto>`
- Form extractors: `DomainForm<T, Dto>`
- Path extractors: `DomainPath<T, Dto>`

---

## Implementation Checklist

### Phase 1: Shared Logic
- [ ] Create `domainstack-http` crate
- [ ] Implement `into_domain<T, Dto>()` helper
- [ ] Implement `validate_dto<Dto>()` helper (optional)
- [ ] Write unit tests
- [ ] Add to workspace

### Phase 2: Axum Adapter
- [ ] Create `domainstack-axum` crate
- [ ] Implement `FromRequest` for `DomainJson<T>`
- [ ] Map `JsonRejection` to `error_envelope::Error`
- [ ] Implement `IntoResponse` for `error_envelope::Error`
- [ ] Write integration tests
- [ ] Create axum-booking example
- [ ] Document in README

### Phase 3: Actix Adapter
- [ ] Create `domainstack-actix` crate
- [ ] Implement `FromRequest` for `DomainJson<T>`
- [ ] Map `JsonPayloadError` to `error_envelope::Error`
- [ ] Implement `ResponseError` for `error_envelope::Error`
- [ ] Write integration tests
- [ ] Create actix-booking example
- [ ] Document in README

### Phase 4: Integration
- [ ] Update workspace Cargo.toml
- [ ] Update root README with adapter examples
- [ ] Update architecture.md diagram
- [ ] Add CI tests for both frameworks
- [ ] Verify cross-framework API consistency

---

## Key Design Decisions

### 1. Framework-Agnostic Core (`domainstack-http`)

**Decision:** Shared logic goes in a separate crate  
**Rationale:** Axum and Actix adapters stay thin, avoid duplication  
**Benefit:** Easier to add Rocket, Warp, etc. adapters later

### 2. Domain-First Extractor (`DomainJson<T>`)

**Decision:** Extractor type parameter is Domain, not DTO  
**Rationale:** Handler sees only valid domain objects  
**Benefit:** Enforces the DTO→Domain boundary

### 3. Same Public API

**Decision:** Both adapters export identical type names  
**Rationale:** Switching frameworks doesn't require code changes  
**Benefit:** Documentation translates, examples portable

### 4. Thin Adapters

**Decision:** Adapters only do framework-specific extraction/response  
**Rationale:** All validation logic stays in domainstack core  
**Benefit:** Adapters are simple, testable, maintainable

---

## Type Gymnastics: How `DomainJson<T>` Infers `Dto`

The trick is using the `TryFrom` bound to infer the DTO type:

```rust
impl<T, Dto, S> FromRequest<S> for DomainJson<T>
where
    Dto: serde::de::DeserializeOwned,
    T: TryFrom<Dto, Error = ValidationError>,
    //  ^^^^^^^^^^^^^^^^ Compiler infers Dto from this!
```

**User code:**
```rust
async fn handler(DomainJson(cmd): DomainJson<CreateBooking>) -> Result<...> {
    // Compiler knows CreateBooking implements TryFrom<CreateBookingDto>
    // So it uses CreateBookingDto for deserialization automatically!
}
```

This keeps the public API clean while still knowing which DTO to deserialize.

---

## Error Mapping Strategy

### JSON Parse Errors
```
Invalid JSON → Framework error → error_envelope::Error::invalid_argument()
```

### Validation Errors
```
ValidationError → (via IntoEnvelopeError) → error_envelope::Error::validation()
```

### Framework Response
```
error_envelope::Error → HTTP 400 with JSON body
```

All three layers produce consistent `error-envelope` format with field-level details.

---

## Example: Axum Booking Service

```rust
use domainstack::Validate;
use domainstack_axum::DomainJson;
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
pub struct CreateBookingDto {
    pub guest_name: String,
    pub email: String,
    pub nights: u8,
}

#[derive(Serialize)]
pub struct CreateBooking {
    guest_name: String,
    email: Email,
    nights: u8,
}

impl TryFrom<CreateBookingDto> for CreateBooking {
    type Error = domainstack::ValidationError;
    
    fn try_from(dto: CreateBookingDto) -> Result<Self, Self::Error> {
        let email = Email::new(dto.email)
            .map_err(|e| e.prefixed("email"))?;
        
        validate("guest_name", dto.guest_name.as_str(),
                 &rules::min_len(1).and(rules::max_len(50)))?;
        validate("nights", &dto.nights, &rules::range(1, 30))?;
        
        Ok(Self {
            guest_name: dto.guest_name,
            email,
            nights: dto.nights,
        })
    }
}

// Handler is ONE LINE of extraction!
async fn create_booking(
    DomainJson(booking): DomainJson<CreateBooking>,
) -> Result<Json<BookingResponse>, error_envelope::Error> {
    // booking is GUARANTEED valid here
    let response = save_booking(booking).await?;
    Ok(Json(response))
}
```

**Before (20+ lines):**
```rust
async fn create_booking_old(
    Json(dto): Json<CreateBookingDto>,
) -> Result<Json<BookingResponse>, StatusCode> {
    // Parse email
    let email = Email::new(dto.email)
        .map_err(|_| StatusCode::BAD_REQUEST)?;
    
    // Validate guest name
    if dto.guest_name.is_empty() || dto.guest_name.len() > 50 {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    // Validate nights
    if dto.nights < 1 || dto.nights > 30 {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    // Build domain object
    let booking = CreateBooking {
        guest_name: dto.guest_name,
        email,
        nights: dto.nights,
    };
    
    // Save...
}
```

**After (3 lines):**
```rust
async fn create_booking(
    DomainJson(booking): DomainJson<CreateBooking>,
) -> Result<Json<BookingResponse>, error_envelope::Error> {
    let response = save_booking(booking).await?;
    Ok(Json(response))
}
```

---

## Testing Strategy

### Unit Tests (domainstack-http)
- Test pure functions
- Mock domain types
- Verify error mapping

### Integration Tests (domainstack-axum/actix)
- Full request/response cycle
- Invalid JSON → 400
- Invalid domain → 400 with field details
- Valid domain → 200
- Error response shape verification

### Example Tests
- Both examples should have same test cases
- Verify identical behavior across frameworks

---

## Documentation Requirements

### Each adapter README should show:

1. **Installation**
   ```toml
   domainstack-axum = "0.4"
   ```

2. **Quick example** (3 lines of handler code)

3. **DTO→Domain pattern** (with TryFrom)

4. **Error response shape** (JSON example)

5. **Link to shared concepts** (domainstack core docs)

### Root README update:

Add "Framework Adapters" section:
- Show both Axum and Actix examples side-by-side
- Emphasize consistency
- Link to adapter crate docs

---

## Release Checklist

- [ ] All tests passing
- [ ] Clippy clean
- [ ] Documentation complete
- [ ] Examples run successfully
- [ ] Update CHANGELOG.md
- [ ] Update version numbers (0.3.0 → 0.4.0 for all crates)
- [ ] Publish in order: http → axum → actix

---

## Future Extensions (v0.5+)

### Query/Path/Form Extractors
```rust
DomainQuery<T, Dto>
DomainPath<T, Dto>
DomainForm<T, Dto>
```

### Async Validation
```rust
trait AsyncValidate {
    async fn validate_async(&self, ctx: &ValidationContext) -> Result<(), ValidationError>;
}
```

### Custom Error Codes
Allow overriding error codes in derive attributes:
```rust
#[validate(length(min = 1, code = "EMPTY_NAME"))]
```

---

## Success Criteria

1. **Handlers are < 5 lines** for common cases
2. **APIs identical** across Axum and Actix
3. **Zero framework deps** in domainstack core
4. **Shared logic** maximized (DRY)
5. **Examples compelling** (clear before/after comparison)
6. **Documentation excellent** (easy to copy-paste)

This keeps domainstack feeling like a **validation library with great framework support**, not a framework itself.
