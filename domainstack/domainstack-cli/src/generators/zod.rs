use crate::parser::{ParsedType, ValidationRule};
use crate::parser::ast::{FieldType, ParsedField};
use anyhow::Result;

/// Generate Zod schemas from parsed types
pub fn generate(types: &[ParsedType]) -> Result<String> {
    let mut output = String::new();

    // Header
    output.push_str("/**\n");
    output.push_str(" * AUTO-GENERATED by domainstack-cli\n");
    output.push_str(" * DO NOT EDIT MANUALLY\n");
    output.push_str(" *\n");
    output.push_str(&format!(" * Generated: {}\n", chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ")));
    output.push_str(" */\n\n");

    // Imports
    output.push_str("import { z } from \"zod\";\n\n");

    // Generate schemas for each type
    for parsed_type in types {
        generate_type_schema(&mut output, parsed_type)?;
        output.push('\n');
    }

    Ok(output)
}

fn generate_type_schema(output: &mut String, parsed_type: &ParsedType) -> Result<()> {
    let schema_name = format!("{}Schema", parsed_type.name);

    // Generate the schema
    output.push_str(&format!("export const {} = z.object({{\n", schema_name));

    for field in &parsed_type.fields {
        output.push_str("  ");
        output.push_str(&field.name);
        output.push_str(": ");
        generate_field_schema(output, field)?;
        output.push_str(",\n");
    }

    output.push_str("});\n\n");

    // Generate TypeScript type
    output.push_str(&format!(
        "export type {} = z.infer<typeof {}>;\n",
        parsed_type.name, schema_name
    ));

    Ok(())
}

fn generate_field_schema(output: &mut String, field: &ParsedField) -> Result<()> {
    // Start with base type
    let base_schema = generate_base_type(&field.ty);
    output.push_str(&base_schema);

    // Add validation rules
    for rule in &field.validation_rules {
        generate_validation_rule(output, rule, &field.ty)?;
    }

    Ok(())
}

fn generate_base_type(field_type: &FieldType) -> String {
    match field_type {
        FieldType::String => "z.string()".to_string(),
        FieldType::Bool => "z.boolean()".to_string(),
        FieldType::U8 | FieldType::U16 | FieldType::U32 |
        FieldType::I8 | FieldType::I16 | FieldType::I32 |
        FieldType::F32 | FieldType::F64 => "z.number()".to_string(),
        FieldType::U64 | FieldType::U128 | FieldType::I64 | FieldType::I128 => {
            // Warn about precision loss
            "z.number() /* Warning: Large integers may lose precision in JavaScript */".to_string()
        }
        FieldType::Option(inner) => {
            format!("{}.optional()", generate_base_type(inner))
        }
        FieldType::Vec(inner) => {
            format!("z.array({})", generate_base_type(inner))
        }
        FieldType::Custom(name) => {
            format!("{}Schema /* Custom type */", name)
        }
    }
}

fn generate_validation_rule(output: &mut String, rule: &ValidationRule, field_type: &FieldType) -> Result<()> {
    match rule {
        // String validations
        ValidationRule::Email => output.push_str(".email()"),
        ValidationRule::Url => output.push_str(".url()"),
        ValidationRule::MinLen(min) => output.push_str(&format!(".min({})", min)),
        ValidationRule::MaxLen(max) => output.push_str(&format!(".max({})", max)),
        ValidationRule::Length { min, max } => {
            output.push_str(&format!(".min({}).max({})", min, max));
        }
        ValidationRule::NonEmpty => output.push_str(".min(1)"),
        ValidationRule::NonBlank => output.push_str(".trim().min(1)"),
        ValidationRule::Alphanumeric => output.push_str(".regex(/^[a-zA-Z0-9]*$/)"),
        ValidationRule::AlphaOnly => output.push_str(".regex(/^[a-zA-Z]*$/)"),
        ValidationRule::NumericString => output.push_str(".regex(/^[0-9]*$/)"),
        ValidationRule::Ascii => output.push_str(".regex(/^[\\x00-\\x7F]*$/)"),
        ValidationRule::StartsWith(prefix) => {
            output.push_str(&format!(".startsWith(\"{}\")", escape_string(prefix)));
        }
        ValidationRule::EndsWith(suffix) => {
            output.push_str(&format!(".endsWith(\"{}\")", escape_string(suffix)));
        }
        ValidationRule::Contains(substring) => {
            output.push_str(&format!(".includes(\"{}\")", escape_string(substring)));
        }
        ValidationRule::MatchesRegex(pattern) => {
            output.push_str(&format!(".regex(/{}/))", escape_regex(pattern)));
        }
        ValidationRule::NoWhitespace => output.push_str(".regex(/^\\S*$/)"),

        // Numeric validations
        ValidationRule::Range { min, max } => {
            output.push_str(&format!(".min({}).max({})", min, max));
        }
        ValidationRule::Min(min) => output.push_str(&format!(".min({})", min)),
        ValidationRule::Max(max) => output.push_str(&format!(".max({})", max)),
        ValidationRule::Positive => output.push_str(".positive()"),
        ValidationRule::Negative => output.push_str(".negative()"),
        ValidationRule::NonZero => output.push_str(".refine(n => n !== 0, { message: \"Must be non-zero\" })"),
        ValidationRule::MultipleOf(divisor) => {
            output.push_str(&format!(".multipleOf({})", divisor));
        }
        ValidationRule::Finite => output.push_str(".finite()"),

        // Custom/unknown rules
        ValidationRule::Custom(name) => {
            output.push_str(&format!(" /* Custom validation: {} not supported */", name));
        }
    }

    Ok(())
}

fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

fn escape_regex(pattern: &str) -> String {
    // Remove leading ^ and trailing $ if present (Zod adds them automatically for regex)
    let pattern = pattern.strip_prefix('^').unwrap_or(pattern);
    let pattern = pattern.strip_suffix('$').unwrap_or(pattern);
    pattern.to_string()
}
